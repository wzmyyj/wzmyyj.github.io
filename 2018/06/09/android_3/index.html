<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="good good study"><title>【android】四种引用比较与源码分析 | wzmyyj</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【android】四种引用比较与源码分析</h1><a id="logo" href="/.">wzmyyj</a><p class="description">a personal page of wzmyyj</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">【android】四种引用比较与源码分析</h1><div class="post-meta"><a href="/2018/06/09/android_3/#comments" class="comment-count"></a><p><span class="date">Jun 09, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="Android四种引用比较与源码分析"><a href="#Android四种引用比较与源码分析" class="headerlink" title="Android四种引用比较与源码分析"></a>Android四种引用比较与源码分析</h2><hr>
<p>【转】：<a href="https://blog.csdn.net/m0_37700275/article/details/79820814" target="_blank" rel="noopener">https://blog.csdn.net/m0_37700275/article/details/79820814</a><br>（版权归原作者所有）<br><a id="more"></a></p>
<h3 id="0-关于四种引用"><a href="#0-关于四种引用" class="headerlink" title="0.关于四种引用"></a>0.关于四种引用</h3><h4 id="0-1-引用说明"><a href="#0-1-引用说明" class="headerlink" title="0.1 引用说明"></a>0.1 引用说明</h4><ul>
<li>java.lang.ref包中提供了几个类：SoftReference类、WeakReference类和PhantomReference类，它们分别代表软引用、弱引用和虚引用。ReferenceQueue类表示引用队列，它可以和这三种引用类联合使用，以便跟踪Java虚拟机回收所引用的对象的活动。</li>
</ul>
<h4 id="0-2-关于Java下ref包和Android下ref包"><a href="#0-2-关于Java下ref包和Android下ref包" class="headerlink" title="0.2 关于Java下ref包和Android下ref包"></a>0.2 关于Java下ref包和Android下ref包</h4><ul>
<li><p>在Android下的ref包结构<br><img src="http://upload-images.jianshu.io/upload_images/3262738-3226f60a6028cb30?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
</li>
<li><p>在java下的ref包<br><img src="http://upload-images.jianshu.io/upload_images/3262738-5c5f09a797ac5d13?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
</li>
</ul>
<h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h3><h4 id="1-0-关于强引用引用的场景"><a href="#1-0-关于强引用引用的场景" class="headerlink" title="1.0 关于强引用引用的场景"></a>1.0 关于强引用引用的场景</h4><ul>
<li>直接new出来的对象</li>
<li>String str = new String(“yc”);</li>
</ul>
<h4 id="1-1-强引用介绍"><a href="#1-1-强引用介绍" class="headerlink" title="1.1 强引用介绍"></a>1.1 强引用介绍</h4><ul>
<li>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</li>
<li>通过引用，可以对堆中的对象进行操作。在某个函数中，当创建了一个对象，该对象被分配在堆中，通过这个对象的引用才能对这个对象进行操作。</li>
</ul>
<h4 id="1-2-强引用的特点"><a href="#1-2-强引用的特点" class="headerlink" title="1.2 强引用的特点"></a>1.2 强引用的特点</h4><ul>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。</li>
<li>强引用可能导致内存泄露。</li>
</ul>
<h4 id="1-3-注意相互引用情况"><a href="#1-3-注意相互引用情况" class="headerlink" title="1.3 注意相互引用情况"></a>1.3 注意相互引用情况</h4><h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h3><h4 id="2-0-关于SoftReference软引用"><a href="#2-0-关于SoftReference软引用" class="headerlink" title="2.0 关于SoftReference软引用"></a>2.0 关于SoftReference软引用</h4><ul>
<li>SoftReference：软引用–&gt;当虚拟机内存不足时，将会回收它指向的对象；需要获取对象时，可以调用get方法。</li>
<li>可以通过java.lang.ref.SoftReference使用软引用。一个持有软引用的对象，不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。当堆的使用率临近阈值时，才会回收软引用的对象。</li>
</ul>
<h4 id="2-1-软引用应用场景"><a href="#2-1-软引用应用场景" class="headerlink" title="2.1 软引用应用场景"></a>2.1 软引用应用场景</h4><ul>
<li>例如从网络上获取图片，然后将获取的图片显示的同时，通过软引用缓存起来。当下次再去网络上获取图片时，首先会检查要获取的图片缓存中是否存在，若存在，直接取出来，不需要再去网络上获取。</li>
</ul>
<h4 id="2-2-软引用的简单使用"><a href="#2-2-软引用的简单使用" class="headerlink" title="2.2 软引用的简单使用"></a>2.2 软引用的简单使用</h4><ul>
<li>用法如下</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MyObject aRef</span> = new  MyObject();</span><br><span class="line"><span class="attribute">SoftReference aSoftRef</span> = new SoftReference(aRef);</span><br><span class="line"><span class="attribute">MyObject anotherRef</span> = (MyObject)aSoftRef.get();</span><br></pre></td></tr></table></figure>
<h4 id="2-3-软引用的特点"><a href="#2-3-软引用的特点" class="headerlink" title="2.3 软引用的特点"></a>2.3 软引用的特点</h4><ul>
<li><strong>2.3.1 特点：</strong></li>
<li>如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</li>
<li><strong>2.3.2 代码如下</strong></li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue<span class="built_in"> queue </span>= new  ReferenceQueue();</span><br><span class="line">SoftReference  ref = new  SoftReference(aMyObject, queue);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>2.3.3 如何回收：</strong></li>
<li>那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。</li>
<li>在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。</li>
<li>常用的方式为</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SoftReference <span class="keyword">ref</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">ref</span> = (EmployeeRef) q.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 清除ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-实际应用案例"><a href="#2-4-实际应用案例" class="headerlink" title="2.4 实际应用案例"></a>2.4 实际应用案例</h4><ul>
<li><strong>2.4.1 正常是用来处理图片这种占用内存大的情况</strong></li>
<li>代码如下所示</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">View</span> <span class="built_in">view</span> = findViewById(R.id.button);</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher);</span><br><span class="line">Drawable drawable = <span class="keyword">new</span> BitmapDrawable(bitmap);</span><br><span class="line">SoftReference&lt;Drawable&gt; drawableSoftReference = <span class="keyword">new</span> SoftReference&lt;Drawable&gt;(drawable);</span><br><span class="line"><span class="keyword">if</span>(drawableSoftReference != <span class="built_in">null</span>) &#123;</span><br><span class="line">    <span class="built_in">view</span>.setBackground(drawableSoftReference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>2.4.2 这样使用软引用好处</strong></li>
<li>通过软引用的get()方法，取得drawable对象实例的强引用，发现对象被未回收。在GC在内存充足的情况下，不会回收软引用对象。此时view的背景显示</li>
<li>实际情况中,我们会获取很多图片.然后可能给很多个view展示, 这种情况下很容易内存吃紧导致oom,内存吃紧，系统开始会GC。这次GC后，drawables.get()不再返回Drawable对象，而是返回null，这时屏幕上背景图不显示，说明在系统内存紧张的情况下，软引用被回收。</li>
<li>使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。</li>
</ul>
<h4 id="2-5-注意避免软引用获取对象为null"><a href="#2-5-注意避免软引用获取对象为null" class="headerlink" title="2.5 注意避免软引用获取对象为null"></a>2.5 注意避免软引用获取对象为null</h4><ul>
<li>在垃圾回收器对这个Java对象回收前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该Java对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。</li>
</ul>
<h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h3><h4 id="3-0-关于WeakReference弱引用"><a href="#3-0-关于WeakReference弱引用" class="headerlink" title="3.0 关于WeakReference弱引用"></a>3.0 关于WeakReference弱引用</h4><ul>
<li><strong>3.0.1 WeakReference</strong></li>
<li>弱引用–&gt;随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收。要获取对象时，同样可以调用get方法。</li>
<li><strong>3.0.2 特点</strong></li>
<li>如果一个对象只具有弱引用，那么在垃圾回收器线程扫描的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</li>
<li>弱引用也可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li>
</ul>
<h4 id="3-1-WeakReference：防止内存泄漏，要保证内存被虚拟机回收"><a href="#3-1-WeakReference：防止内存泄漏，要保证内存被虚拟机回收" class="headerlink" title="3.1 WeakReference：防止内存泄漏，要保证内存被虚拟机回收"></a>3.1 WeakReference：防止内存泄漏，要保证内存被虚拟机回收</h4><ul>
<li><p><strong>3.1.1 先看一个handler小案例【千万不要忽视淡黄色警告】</strong><br><img src="http://upload-images.jianshu.io/upload_images/3262738-9eebc092c38ea46f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
</li>
<li><p><strong>3.1.2 为什么这样会造成内存泄漏</strong></p>
</li>
<li><p>这种情况就是由于android的特殊机制造成的：当一个android主线程被创建的时候，同时会有一个Looper对象被创建，而这个Looper对象会实现一个MessageQueue(消息队列)，当我们创建一个handler对象时，而handler的作用就是放入和取出消息从这个消息队列中，每当我们通过handler将一个msg放入消息队列时，这个msg就会持有一个handler对象的引用。因此当Activity被结束后，这个msg在被取出来之前，这msg会继续存活，但是这个msg持有handler的引用，而handler在Activity中创建，会持有Activity的引用，因而当Activity结束后，Activity对象并不能够被gc回收，因而出现内存泄漏。</p>
</li>
<li><p><strong>3.1.3 根本原因</strong></p>
</li>
<li><p>Activity在被结束之后，MessageQueue并不会随之被结束，如果这个消息队列中存在msg，则导致持有handler的引用，但是又由于Activity被结束了，msg无法被处理，从而导致永久持有handler对象，handler永久持有Activity对象，于是发生内存泄漏。但是为什么为static类型就会解决这个问题呢？因为在java中所有非静态的对象都会持有当前类的强引用，而静态对象则只会持有当前类的弱引用。声明为静态后，handler将会持有一个Activity的弱引用，而弱引用会很容易被gc回收，这样就能解决Activity结束后，gc却无法回收的情况。</p>
</li>
</ul>
<h4 id="3-2-弱引用解决办法"><a href="#3-2-弱引用解决办法" class="headerlink" title="3.2 弱引用解决办法"></a>3.2 弱引用解决办法</h4><ul>
<li>代码如下所示</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">MyHandler</span> handler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="type">WeakReference</span>&lt;<span class="type">FirstActivity</span>&gt; weakReference;</span><br><span class="line">    <span class="type">MyHandler</span>(<span class="type">FirstActivity</span> activity) &#123;</span><br><span class="line">        weakReference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void handleMessage(<span class="type">Message</span> msg) &#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        switch (msg.what)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-弱引用实际应用案例"><a href="#3-3-弱引用实际应用案例" class="headerlink" title="3.3 弱引用实际应用案例"></a>3.3 弱引用实际应用案例</h4><ul>
<li><p>具体案例可以参考我的代码：<a href="https://github.com/yangchong211/YCVideoPlayer" target="_blank" rel="noopener">https://github.com/yangchong211/YCVideoPlayer</a><br><img src="http://upload-images.jianshu.io/upload_images/3262738-bc142269e4e6a298?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3262738-dc4b28a2c4437b60?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
</li>
</ul>
<h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h3><h4 id="4-0-关于PhantomReference类虚引用"><a href="#4-0-关于PhantomReference类虚引用" class="headerlink" title="4.0 关于PhantomReference类虚引用"></a>4.0 关于PhantomReference类虚引用</h4><ul>
<li>虚引用是所有引用类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，奖这个虚引用加入引用队列。</li>
</ul>
<h4 id="4-1-Android实际开发中没有用到过"><a href="#4-1-Android实际开发中没有用到过" class="headerlink" title="4.1 Android实际开发中没有用到过"></a>4.1 Android实际开发中没有用到过</h4><ul>
<li>貌似开发中没有接触过虚引用</li>
</ul>
<h3 id="5-四种引用其他介绍"><a href="#5-四种引用其他介绍" class="headerlink" title="5.四种引用其他介绍"></a>5.四种引用其他介绍</h3><h4 id="5-1-弱引用和软引用区别"><a href="#5-1-弱引用和软引用区别" class="headerlink" title="5.1 弱引用和软引用区别"></a>5.1 弱引用和软引用区别</h4><ul>
<li>弱引用与软引用的根本区别在于：只具有弱引用的对象拥有更短暂的生命周期，可能随时被回收。而只具有软引用的对象只有当内存不够的时候才被回收，在内存足够的时候，通常不被回收。</li>
</ul>
<h4 id="5-2-使用软引用或者弱引用防止内存泄漏"><a href="#5-2-使用软引用或者弱引用防止内存泄漏" class="headerlink" title="5.2 使用软引用或者弱引用防止内存泄漏"></a>5.2 使用软引用或者弱引用防止内存泄漏</h4><ul>
<li>在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。</li>
<li>软引用，弱引用都非常适合来保存那些可有可无的缓存数据。如果这样做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间。</li>
</ul>
<h4 id="5-3-到底什么时候使用软引用，什么时候使用弱引用呢？"><a href="#5-3-到底什么时候使用软引用，什么时候使用弱引用呢？" class="headerlink" title="5.3 到底什么时候使用软引用，什么时候使用弱引用呢？"></a>5.3 到底什么时候使用软引用，什么时候使用弱引用呢？</h4><ul>
<li>个人认为，如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</li>
<li>还有就是可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</li>
<li>另外，和弱引用功能类似的是WeakHashMap。WeakHashMap对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的回收，回收以后，其条目从映射中有效地移除。WeakHashMap使用ReferenceQueue实现的这种机制。</li>
</ul>
<h4 id="5-4-四种引用用一张表总结-摘自网络"><a href="#5-4-四种引用用一张表总结-摘自网络" class="headerlink" title="5.4 四种引用用一张表总结[摘自网络]"></a>5.4 四种引用用一张表总结[摘自网络]</h4><p><img src="http://upload-images.jianshu.io/upload_images/3262738-380b77705ce16dd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="6-源码分析"><a href="#6-源码分析" class="headerlink" title="6.源码分析"></a>6.源码分析</h3><h4 id="6-1-首先看看如何通过弱引用加载图片"><a href="#6-1-首先看看如何通过弱引用加载图片" class="headerlink" title="6.1 首先看看如何通过弱引用加载图片"></a>6.1 首先看看如何通过弱引用加载图片</h4><p><img src="http://upload-images.jianshu.io/upload_images/3262738-957f22bd72f0adb1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="6-2-看看Reference的源代码"><a href="#6-2-看看Reference的源代码" class="headerlink" title="6.2 看看Reference的源代码"></a>6.2 看看Reference的源代码</h4><ul>
<li><strong>6.2.1 源码说明：</strong></li>
<li>看到Reference除了带有对象引用referent的构造函数，还有一个带有ReferenceQueue参数的构造函数。那么这个ReferenceQueue用来做什么呢？</li>
<li>需要我们从enqueue这个函数来开始分析。当系统要回收Reference持有的对象引用referent的时候，Reference的enqueue函数会被调用，而在这个函数中调用了ReferenceQueue的enqueue函数。</li>
<li><p>那么我们来看看ReferenceQueue的enqueue函数做了什么？</p>
</li>
<li><p><strong>6.2.2 看看这段源代码</strong></p>
</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> disableIntrinsic = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> slowPathEnabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">volatile</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line">    <span class="keyword">final</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br><span class="line">    Reference queueNext;</span><br><span class="line">    Reference&lt;?&gt; pendingNext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此引用对象的引用。如果这个引用对象有由程序或垃圾收集器清除，然后此方法返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">getReferent</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function">T <span class="title">getReferent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除此引用对象。调用此方法不会将对象加入队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否引用对象已进入队列，由程序或垃圾收集器。</span></span><br><span class="line">    <span class="comment">//如果该引用对象在创建队列时没有注册，则该方法将始终返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isEnqueued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue != <span class="keyword">null</span> &amp;&amp; queue.isEnqueued(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加引用对象到其注册的队列，如果他的方法是通过java代码调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> queue != <span class="keyword">null</span> &amp;&amp; queue.enqueue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Reference(T referent) &#123;</span><br><span class="line">        <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = referent;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-看看ReferenceQueue的enqueue函数"><a href="#6-3-看看ReferenceQueue的enqueue函数" class="headerlink" title="6.3 看看ReferenceQueue的enqueue函数"></a>6.3 看看ReferenceQueue的enqueue函数</h4><ul>
<li><strong>6.3.1 源码说明</strong></li>
<li>可以看到首先获取同步锁，然后调用了enqueueLocked(Reference)函数</li>
<li><strong>6.3.2 看看这段代码</strong><br><img src="http://upload-images.jianshu.io/upload_images/3262738-f2fe3516685e500d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
</ul>
<h4 id="6-4-看看ReferenceQueue的enqueueLocked-Reference-函数"><a href="#6-4-看看ReferenceQueue的enqueueLocked-Reference-函数" class="headerlink" title="6.4 看看ReferenceQueue的enqueueLocked(Reference)函数"></a>6.4 看看ReferenceQueue的enqueueLocked(Reference)函数</h4><ul>
<li><strong>6.4.1 源码说明</strong></li>
<li>通过 enqueueLocked函数可以看到ReferenceQueue维护了一个队列（链表结构），而enqueue这一系列函数就是将reference添加到这个队列（链表）中</li>
<li><strong>6.4.2 看看这段代码</strong><br><img src="http://upload-images.jianshu.io/upload_images/3262738-0b339f9059f78f62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
</ul>
<h4 id="6-5-接着看看ReferenceQueue-isEnqueued-代码"><a href="#6-5-接着看看ReferenceQueue-isEnqueued-代码" class="headerlink" title="6.5 接着看看ReferenceQueue.isEnqueued()代码"></a>6.5 接着看看ReferenceQueue.isEnqueued()代码</h4><ul>
<li><strong>6.5.1 让我们回到Reference源码中</strong></li>
<li>可以看到除了enqueue这个函数还有一个isEnqueued函数，同样这个函数调用了ReferenceQueue的同名函数，源码如下：</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEnqueued</span><span class="params">(Reference&lt;? <span class="keyword">extends</span> T&gt; reference)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">return</span> reference.queueNext != <span class="keyword">null</span> &amp;&amp; reference.queueNext != sQueueNextUnenqueued;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>6.5.2 源码分析说明</strong></li>
<li>可以看到先获取同步锁，然后判断该reference是否在队列（链表）中。由于enqueue和isEnqueue函数都要申请同步锁，所以这是线程安全的。</li>
<li>这里要注意“reference.queueNext != sQueueNextUnenqueued”用于判断该Reference是否是一个Cleaner类，在上面ReferenceQueue的enqueueLocked函数中我们可以看到如果一个Reference是一个Cleaner，则调用它的clean方法，同时并不加入链表，并且将其queueNext设置为sQueueNextUnequeued，这是一个空的虚引用</li>
</ul>
<h4 id="6-6-那么enqueueLocked-Reference-函数中的Cleaner是做什么的"><a href="#6-6-那么enqueueLocked-Reference-函数中的Cleaner是做什么的" class="headerlink" title="6.6 那么enqueueLocked(Reference)函数中的Cleaner是做什么的"></a>6.6 那么enqueueLocked(Reference)函数中的Cleaner是做什么的</h4><ul>
<li><p>在stackoverflow网站中找到这个解释 </p>
<ul>
<li>sun.misc.Cleaner是JDK内部提供的用来释放非堆内存资源的API。JVM只会帮我们自动释放堆内存资源，但是它提供了回调机制，通过这个类能方便的释放系统的其他资源。</li>
<li>可以看到Cleaner是用于释放非堆内存的，所以做特殊处理。</li>
<li>通过enqueue和isEnqueue两个函数的分析，ReferenceQueue队列维护了那些被回收对象referent的Reference的引用，这样通过isEnqueue就可以判断对象referent是否已经被回收，用于一些情况的处理。</li>
</ul>
</li>
</ul>
<h4 id="6-7-软引用SoftReference源码"><a href="#6-7-软引用SoftReference源码" class="headerlink" title="6.7 软引用SoftReference源码"></a>6.7 软引用SoftReference源码</h4><ul>
<li><strong>6.7.1 关于这段源码分析</strong></li>
<li><p>可以看到SoftReference有一个类变量clock和一个变量timestamp，这两个参数对于SoftReference至关重要。 </p>
<ul>
<li>clock：记录了上一次GC的时间。这个变量由GC（garbage collector）来改变。</li>
<li>timestamp：记录对象被访问（get函数）时最近一次GC的时间。</li>
</ul>
</li>
<li><p>那么这两个参数有什么用？ </p>
<ul>
<li>我们知道软引用是当内存不足时可以回收的。但是这只是大致情况，实际上软应用的回收有一个条件：</li>
<li>clock - timestamp &lt;= free_heap * ms_per_mb</li>
<li>free_heap是JVM Heap的空闲大小，单位是MB</li>
<li>ms_per_mb单位是毫秒，是每MB空闲允许保留软引用的时间。Sun JVM可以通过参数-XX:SoftRefLRUPolicyMSPerMB进行设置</li>
</ul>
</li>
<li><p>举个栗子：</p>
<ul>
<li>目前有3MB的空闲，ms_per_mb为1000，这时如果clock和timestamp分别为5000和2000，那么</li>
<li>5000 - 2000 &lt;= 3 * 1000</li>
<li>条件成立，则该次GC不对该软引用进行回收。</li>
<li>所以每次GC时，通过上面的条件去判断软应用是否可以回收并进行回收，即我们通常说的内存不足时被回收。</li>
</ul>
</li>
<li><strong>6.7.2 源码如下所示</strong></li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SoftReference&lt;T&gt; extends Reference&lt;T&gt; &#123; </span><br><span class="line">    static private long<span class="built_in"> clock; </span></span><br><span class="line">    private long timestamp; </span><br><span class="line">    public SoftReference(T referent) &#123; </span><br><span class="line">        super(referent); </span><br><span class="line">        this.timestamp =<span class="built_in"> clock; </span></span><br><span class="line">    &#125; </span><br><span class="line">    public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; </span><br><span class="line">        super(referent, q); </span><br><span class="line">        this.timestamp =<span class="built_in"> clock; </span></span><br><span class="line">    &#125; </span><br><span class="line">    public T <span class="builtin-name">get</span>() &#123; </span><br><span class="line">        T o = super.<span class="builtin-name">get</span>(); </span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">null</span> &amp;&amp; this.timestamp != clock) </span><br><span class="line">            this.timestamp =<span class="built_in"> clock; </span></span><br><span class="line">        return o; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-8-弱引用WeakReference源码"><a href="#6-8-弱引用WeakReference源码" class="headerlink" title="6.8 弱引用WeakReference源码"></a>6.8 弱引用WeakReference源码</h4><ul>
<li><strong>6.8.1 源码分析说明</strong></li>
<li>没有其他代码，GC时被回收掉。</li>
<li><strong>6.8.2 源码如下所示</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WeakReference&lt;T&gt;</span> <span class="keyword">extends</span> <span class="title">Reference&lt;T&gt;</span> </span>&#123; </span><br><span class="line">    public <span class="type">WeakReference</span>(<span class="type">T</span> referent) &#123; </span><br><span class="line">        <span class="keyword">super</span>(referent); </span><br><span class="line">    &#125; </span><br><span class="line">    public <span class="type">WeakReference</span>(<span class="type">T</span> referent, <span class="type">ReferenceQueue</span>&lt;? <span class="keyword">super</span> <span class="type">T</span>&gt; q) &#123; </span><br><span class="line">        <span class="keyword">super</span>(referent, q); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-9-虚引用PhantomReference源码"><a href="#6-9-虚引用PhantomReference源码" class="headerlink" title="6.9 虚引用PhantomReference源码"></a>6.9 虚引用PhantomReference源码</h4><ul>
<li><strong>6.9.1 源码分析说明</strong></li>
<li>可以看到get函数返回null，正如前面说得虚引用无法获取对象引用。（注意网上有些文章说虚引用不持有对象的引用，这是有误的，通过构造函数可以看到虚引用是持有对象引用的，但是无法获取该引用</li>
<li>同时可以看到虚引用只有一个构造函数，所以必须传入ReferenceQueue对象。</li>
<li>前面提到虚引用的作用是判断对象是否被回收，这个功能正是通过ReferenceQueue实现的。</li>
<li><p>这里注意：不仅仅是虚引用可以判断回收，弱引用和软引用同样实现了带有ReferenceQueue的构造函数，如果创建时传入了一个ReferenceQueue对象，同样也可以判断。</p>
</li>
<li><p><strong>6.9.2 源码如下所示</strong></p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference&lt;T&gt;</span> <span class="keyword">extends</span> <span class="title">Reference&lt;T&gt;</span> </span>&#123; </span><br><span class="line">    public <span class="type">T</span> get() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    public <span class="type">PhantomReference</span>(<span class="type">T</span> referent, <span class="type">ReferenceQueue</span>&lt;? <span class="keyword">super</span> <span class="type">T</span>&gt; q) &#123; </span><br><span class="line">        <span class="keyword">super</span>(referent, q); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-附件"><a href="#7-附件" class="headerlink" title="7.附件"></a>7.附件</h3><p>原文地址：<a href="https://blog.csdn.net/m0_37700275/article/details/79820814" target="_blank" rel="noopener">https://blog.csdn.net/m0_37700275/article/details/79820814</a></p>
</div><div class="tags"><a href="/tags/android/">android</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/06/09/it_5/" class="next">【IT】关于HTTP协议你需要知道这些</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android四种引用比较与源码分析"><span class="toc-text">Android四种引用比较与源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-关于四种引用"><span class="toc-text">0.关于四种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1-引用说明"><span class="toc-text">0.1 引用说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0-2-关于Java下ref包和Android下ref包"><span class="toc-text">0.2 关于Java下ref包和Android下ref包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-强引用"><span class="toc-text">1.强引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-0-关于强引用引用的场景"><span class="toc-text">1.0 关于强引用引用的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-强引用介绍"><span class="toc-text">1.1 强引用介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-强引用的特点"><span class="toc-text">1.2 强引用的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-注意相互引用情况"><span class="toc-text">1.3 注意相互引用情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-软引用"><span class="toc-text">2.软引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-0-关于SoftReference软引用"><span class="toc-text">2.0 关于SoftReference软引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-软引用应用场景"><span class="toc-text">2.1 软引用应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-软引用的简单使用"><span class="toc-text">2.2 软引用的简单使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-软引用的特点"><span class="toc-text">2.3 软引用的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-实际应用案例"><span class="toc-text">2.4 实际应用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-注意避免软引用获取对象为null"><span class="toc-text">2.5 注意避免软引用获取对象为null</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-弱引用"><span class="toc-text">3.弱引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-0-关于WeakReference弱引用"><span class="toc-text">3.0 关于WeakReference弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-WeakReference：防止内存泄漏，要保证内存被虚拟机回收"><span class="toc-text">3.1 WeakReference：防止内存泄漏，要保证内存被虚拟机回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-弱引用解决办法"><span class="toc-text">3.2 弱引用解决办法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-弱引用实际应用案例"><span class="toc-text">3.3 弱引用实际应用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-虚引用"><span class="toc-text">4.虚引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-0-关于PhantomReference类虚引用"><span class="toc-text">4.0 关于PhantomReference类虚引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Android实际开发中没有用到过"><span class="toc-text">4.1 Android实际开发中没有用到过</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-四种引用其他介绍"><span class="toc-text">5.四种引用其他介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-弱引用和软引用区别"><span class="toc-text">5.1 弱引用和软引用区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-使用软引用或者弱引用防止内存泄漏"><span class="toc-text">5.2 使用软引用或者弱引用防止内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-到底什么时候使用软引用，什么时候使用弱引用呢？"><span class="toc-text">5.3 到底什么时候使用软引用，什么时候使用弱引用呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-四种引用用一张表总结-摘自网络"><span class="toc-text">5.4 四种引用用一张表总结[摘自网络]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-源码分析"><span class="toc-text">6.源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-首先看看如何通过弱引用加载图片"><span class="toc-text">6.1 首先看看如何通过弱引用加载图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-看看Reference的源代码"><span class="toc-text">6.2 看看Reference的源代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-看看ReferenceQueue的enqueue函数"><span class="toc-text">6.3 看看ReferenceQueue的enqueue函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-看看ReferenceQueue的enqueueLocked-Reference-函数"><span class="toc-text">6.4 看看ReferenceQueue的enqueueLocked(Reference)函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-接着看看ReferenceQueue-isEnqueued-代码"><span class="toc-text">6.5 接着看看ReferenceQueue.isEnqueued()代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-那么enqueueLocked-Reference-函数中的Cleaner是做什么的"><span class="toc-text">6.6 那么enqueueLocked(Reference)函数中的Cleaner是做什么的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-软引用SoftReference源码"><span class="toc-text">6.7 软引用SoftReference源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-弱引用WeakReference源码"><span class="toc-text">6.8 弱引用WeakReference源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-虚引用PhantomReference源码"><span class="toc-text">6.9 虚引用PhantomReference源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-附件"><span class="toc-text">7.附件</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/09/android_3/">【android】四种引用比较与源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/09/it_5/">【IT】关于HTTP协议你需要知道这些</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/java_2/">【java】获取中文首字母</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/it_4/">【IT】Hexo+GitHub搭建个人博客网站</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/it_3/">【IT】提问的智慧</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/pic_1/">【图片】仅仅是几张图而已哦^_^</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/android_2/">【android】封装使用Toast</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/android_1/">【android】日志工具Log类</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/18/design_3/">【设计模式】工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/design_2/">【设计模式】单例模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/IT/" style="font-size: 15px;">IT</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/图片/" style="font-size: 15px;">图片</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://shiyi.today/" title="李昊昊：诗意" target="_blank">李昊昊：诗意</a><ul></ul><a href="https://wangzeliangbsd.github.io/" title="王亮亮：WZL Blog" target="_blank">王亮亮：WZL Blog</a><ul></ul><a href="https://foreverlf.github.io/" title="方胖子：ForeverLF" target="_blank">方胖子：ForeverLF</a><ul></ul><a href="https://zqhgit.github.io/" title="曾小辉：Sprider" target="_blank">曾小辉：Sprider</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">baidusitemap</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">wzmyyj.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"superSample":2,"width":100,"height":200,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.1},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body></html>