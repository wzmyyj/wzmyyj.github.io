<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wzmyyj</title>
  
  <subtitle>a personal page of wzmyyj</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wzmyyj.top/"/>
  <updated>2018-06-02T03:54:48.815Z</updated>
  <id>http://wzmyyj.top/</id>
  
  <author>
    <name>wzmyyj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【图片】一些动漫图片</title>
    <link href="http://wzmyyj.top/2018/06/01/pic_1/"/>
    <id>http://wzmyyj.top/2018/06/01/pic_1/</id>
    <published>2018-06-01T13:20:06.000Z</published>
    <updated>2018-06-02T03:54:48.815Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3262738-0a5b030907019fd8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gnnsss.jpg"></p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/3262738-1f1bcd714aa0813c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mobile.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3262738-a3c676432cc233b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="top.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3262738-3cd7e10ae7b522d6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kgy.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3262738-c0beadca93f5962e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="assdf.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3262738-ead0b680c718d0f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="asvj.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3262738-bc78712dc55e2ca9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a0e9b8dd.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3262738-52a9711439ee133d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wzm.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3262738-0a5b030907019fd8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gnnsss.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="图片" scheme="http://wzmyyj.top/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】工厂模式</title>
    <link href="http://wzmyyj.top/2018/05/18/design_3/"/>
    <id>http://wzmyyj.top/2018/05/18/design_3/</id>
    <published>2018-05-18T09:52:10.000Z</published>
    <updated>2018-05-30T09:38:24.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><strong>工厂模式</strong>（Factory Pattern）就是专门负责将大量有共同接口的类实例化，而且不必事先知道每次是要实例化哪一个类的模式。它定义一个用于创建对象的接口，由子类决定实例化哪一个类。工厂模式相当于创建实例对象的new，经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的。</p><a id="more"></a><h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://upload-images.jianshu.io/upload_images/3262738-b1a29ff116e6f1ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工厂方法模式"></p><ol><li>抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。</li><li>具体产品类（ProductX）：实现基类中的抽象方法（多个不同的具体产品，X=1,2,3..）。</li><li>抽象工厂类或接口（AbstractFactory）：定义具体工厂的公共接口。</li><li>具体工厂类（FactoryX）：定义创建对应具体产品实例的方法。（每个工厂对应一种具体产品，X=1,2,3…）。</li></ol><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>既然是工厂，当然是要生产产品。那我们来造什么好呢？，，嗯，，，造小孩？NO，NO，NO！我们还是来造英雄吧。</p><p>场景：玩《英雄联盟》（5v5 moba端游）新开一局游戏，游戏开始每个玩家需要选一个信赖的英雄。选好后，英雄会很兴奋，说一句专属的台词。那么程序上是<code>new</code>出该英雄的对象，执行该对象的<code>say()</code>方法。</p><h4 id="常规写法："><a href="#常规写法：" class="headerlink" title="常规写法："></a>常规写法：</h4><p>建立英雄类：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>寒冰射手-艾希类（继承<code>Hero</code>类）：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Ashe</span> <span class="keyword">extends</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化构造方法，只弄个名字。</span></span><br><span class="line">public <span class="type">Ashe</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"寒冰射手-艾希"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 艾希台词</span></span><br><span class="line"><span class="comment">// 艾希台词</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public void say() &#123;</span><br><span class="line"><span class="type">System</span>.out.println(name + <span class="string">"："</span> + <span class="string">"世间万物皆系于一箭之上。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似的写了亚索类，光辉类，盖伦类，剑圣类（全部英雄的话，还有好多）。再写个枚举（可以不需要，仅仅拿来当对应标识使用）。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Who</span> &#123;</span></span><br><span class="line">Ashe,</span><br><span class="line">Garen,</span><br><span class="line">Yi,</span><br><span class="line">Lux,</span><br><span class="line">Yasuo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后客户端调用：（菜鸟写法）<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">Scanner can = <span class="keyword">new</span> <span class="type">Scanner</span>(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="keyword">String</span> name = can.next();</span><br><span class="line">can.close();</span><br><span class="line"><span class="keyword">switch</span> (Who.valueOf(name)) &#123;</span><br><span class="line"><span class="keyword">case</span> Ashe:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 艾希</span><br><span class="line">Ashe ashe = <span class="keyword">new</span> <span class="type">Ashe</span>();</span><br><span class="line">ashe.say();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Yasuo:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 亚索</span><br><span class="line">Yasuo yasuo = <span class="keyword">new</span> <span class="type">Yasuo</span>();</span><br><span class="line">yasuo.say();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Garen:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 德玛</span><br><span class="line">Garen garen = <span class="keyword">new</span> <span class="type">Garen</span>();</span><br><span class="line">garen.say();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Lux:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 光辉</span><br><span class="line">Lux lux = <span class="keyword">new</span> <span class="type">Lux</span>();</span><br><span class="line">lux.say();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Yi:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 剑圣</span><br><span class="line">Yi yi = <span class="keyword">new</span> <span class="type">Yi</span>();</span><br><span class="line">yi.say();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/3262738-d675c52f807885a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="艾希"></p><p>客户端调用：（好学生写法，<strong>父类的子类引用</strong>）<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">Scanner can = <span class="keyword">new</span> <span class="type">Scanner</span>(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="keyword">String</span> name = can.next();</span><br><span class="line">can.close();</span><br><span class="line">Hero hero = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (Who.valueOf(name)) &#123;</span><br><span class="line"><span class="keyword">case</span> Ashe:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 艾希</span><br><span class="line">hero = <span class="keyword">new</span> <span class="type">Ashe</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Yasuo:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 亚索</span><br><span class="line">hero = <span class="keyword">new</span> <span class="type">Yasuo</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Garen:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 德玛</span><br><span class="line">hero = <span class="keyword">new</span> <span class="type">Garen</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Lux:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 光辉</span><br><span class="line">hero = <span class="keyword">new</span> <span class="type">Lux</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Yi:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 剑圣</span><br><span class="line">hero = <span class="keyword">new</span> <span class="type">Yi</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">hero.say();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里客户端需要知道：</p><ul><li>英雄怎么构造，怎么<code>new</code>出来。（事实上英雄的构造远没有这么简单。）</li><li>每个英雄的方法怎么调用。（这里都是<code>say()</code>方法）</li></ul><p>我们前面提到，利用工厂可以把创建对象的过程封装掉，客户端只要知道得到对象后调用其方法即可。用工厂代替<code>new</code>的过程。那就看看工厂方法怎么去实现吧。</p><h4 id="工厂模式写法"><a href="#工厂模式写法" class="headerlink" title="工厂模式写法"></a>工厂模式写法</h4><p>先建立一个工厂类的接口：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Factory</span> &#123;</span><br><span class="line"><span class="comment">//创建英雄的接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Hero <span class="title">create</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后建立不同英雄对应的工厂实现类。比如艾希工厂：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsheFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Factory</span></span> </span>&#123;</span><br><span class="line"><span class="comment">//实现具体的创建英雄的方法。</span></span><br><span class="line"><span class="keyword">public</span> Hero create() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Ashe</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的建立亚索工厂，光辉工厂，盖伦工厂，剑圣工厂等。</p><p>然后客户端调用：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Client3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">Scanner can = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="built_in">String</span> name = can.next();</span><br><span class="line">can.close();</span><br><span class="line">Factory <span class="keyword">factory</span> = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (Who.valueOf(name)) &#123;</span><br><span class="line"><span class="keyword">case</span> Ashe:</span><br><span class="line"><span class="comment">// 艾希工厂</span></span><br><span class="line"><span class="keyword">factory</span> = <span class="keyword">new</span> AsheFactory();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Yasuo:</span><br><span class="line"><span class="comment">// 亚索工厂</span></span><br><span class="line"><span class="keyword">factory</span> = <span class="keyword">new</span> YasuoFactory();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Garen:</span><br><span class="line"><span class="comment">// 德玛工厂</span></span><br><span class="line"><span class="keyword">factory</span> = <span class="keyword">new</span> GarenFactory();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Lux:</span><br><span class="line"><span class="comment">// 光辉工厂</span></span><br><span class="line"><span class="keyword">factory</span> = <span class="keyword">new</span> LuxFactory();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Yi:</span><br><span class="line"><span class="comment">// 剑圣工厂</span></span><br><span class="line"><span class="keyword">factory</span> = <span class="keyword">new</span> YiFactory();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Hero hero = <span class="keyword">factory</span>.create();</span><br><span class="line">hero.say();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>switch</code>中不再是英雄的创建过程，而是选择英雄工厂的过程。根据不同<code>name</code>选择不同的工厂，然后由工厂去实例化具体英雄对象。</p><p>新增一个英雄，就新增一个对应的工厂。需要修改的只有客户端代码。</p><p>如果不需要新增也不需要减少。我们是不是可以把工厂的选择封装起来。让多家工厂合并成一家工厂。那就是接下来要讲的<strong>简单工厂模式</strong></p><hr><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>简单工厂模式</strong>（Simple Factory Pattern）是类的创建模式，又叫做<strong>静态工厂方法模式</strong>。就是由一个工厂类根据传入的参量决定创建出哪一种产品类的实例。与上面<strong>工厂模式</strong>的区别就是它只需要一个工厂。</p><h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://upload-images.jianshu.io/upload_images/3262738-0e5ef8eefbd001f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简单工厂模式"></p><ol><li>抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。</li><li>具体产品类（ConcreteProduct）：实现基类中的抽象方法。</li><li>工厂类（Factory）：用以封装实例化对象过程，根据传入的参数决定生产不同的产品。</li></ol><h5 id="利用简单工厂的写法："><a href="#利用简单工厂的写法：" class="headerlink" title="利用简单工厂的写法："></a>利用简单工厂的写法：</h5><p>其他地方不变，将工厂合并成一个工厂类，并在内部写个静态方法，根据传入的参数决定创建不同的英雄对象：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Hero create(<span class="keyword">String</span> name) &#123;</span><br><span class="line">Hero hero = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (Who.valueOf(name)) &#123;</span><br><span class="line"><span class="keyword">case</span> Ashe:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 艾希</span><br><span class="line">hero = <span class="keyword">new</span> <span class="type">Ashe</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Yasuo:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 亚索</span><br><span class="line">hero = <span class="keyword">new</span> <span class="type">Yasuo</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Garen:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 德玛</span><br><span class="line">hero = <span class="keyword">new</span> <span class="type">Garen</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Lux:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 光辉</span><br><span class="line">hero = <span class="keyword">new</span> <span class="type">Lux</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Yi:<span class="type"></span></span><br><span class="line"><span class="type"></span>// 剑圣</span><br><span class="line">hero= <span class="keyword">new</span> <span class="type">Yi</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hero;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端代码做简单修改：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client4</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">Scanner can = <span class="keyword">new</span> <span class="type">Scanner</span>(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="keyword">String</span> name = can.next();</span><br><span class="line">can.close();</span><br><span class="line"><span class="comment">// 根据传入的名字构建不同的英雄。</span></span><br><span class="line">Hero hero = SimpleFactory.create(name);</span><br><span class="line">hero.say();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端不需要知道对象的构建过程，只要传入参数得到不同对象。</p><p>但是简单工厂是固定的，如果增减英雄他就要修改。不符合<strong>开闭原则</strong>。这时候用前面<strong>工厂模式</strong>好，把修改转移给客户端，而不修改工厂代码。</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>选个盖伦试试：</p><p><img src="https://upload-images.jianshu.io/upload_images/3262738-4f670dad3f205f86.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="盖伦"></p><p>不能浪，不能浪。</p><hr><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>请看下篇<a href="https://www.jianshu.com/p/06fd85ca913b" target="_blank" rel="noopener">【设计模式】抽象工厂模式</a>。</p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>设计模式Demo<br>GitHub源码：<a href="https://github.com/wzmyyj/Design-Pattern" target="_blank" rel="noopener">https://github.com/wzmyyj/Design-Pattern</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;工厂模式&lt;/strong&gt;（Factory Pattern）就是专门负责将大量有共同接口的类实例化，而且不必事先知道每次是要实例化哪一个类的模式。它定义一个用于创建对象的接口，由子类决定实例化哪一个类。工厂模式相当于创建实例对象的new，经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://wzmyyj.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】单例模式</title>
    <link href="http://wzmyyj.top/2018/04/17/design_2/"/>
    <id>http://wzmyyj.top/2018/04/17/design_2/</id>
    <published>2018-04-17T13:20:06.000Z</published>
    <updated>2018-05-30T09:38:49.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>单例模式</strong>（Singleton Pattern）是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。</p><a id="more"></a><ol><li>某个类只能有一个实例。</li><li>它必须自行创建这个实例。</li><li>它必须自行向整个系统提供这个实例。</li></ol><p>单例模式关键点：</p><ul><li>构造函数私有化（不让外部创建此类对象）。</li><li>通过一个静态方法或枚举返回单例类对象。</li><li>多线程环境下，确保单例（难点）。</li><li>反序列化不会重新构建对象。</li></ul><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// 单例对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="comment">// private final static Singleton INSTANCE;</span></span><br><span class="line"><span class="comment">// static &#123;</span></span><br><span class="line"><span class="comment">// INSTANCE = new Singleton();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公有静态方法用于获取单例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全。但是没使用它时，就已经建立了对象，开销内存。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// 单例对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized关键字修饰静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;<span class="comment">// 空值判断</span></span><br><span class="line">INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一次调用<code>getInstance()</code>时，创建单例对象。<code>synchronized</code>关键字修饰，使<code>getInstance()</code>是一个同步方法。保证多线程情况下单例对象的唯一。但是，同步会耗费资源。</p><h2 id="双检锁式（Double-Check-Lock（DCL））"><a href="#双检锁式（Double-Check-Lock（DCL））" class="headerlink" title="双检锁式（Double Check Lock（DCL））"></a>双检锁式（Double Check Lock（DCL））</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// 单例对象，volatile关键字保证INSTANCE的原子性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两次空值检查，synchronized关键字同步</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句<code>INSTANCE = new Singleton();</code>在编译时的步骤如下：</p><ol><li>给Singleton的实例分配内存。</li><li>调用Singleton()的构造函数，初始化成员字段。</li><li>将INSTANCE 对象指向分配的内存空间（此时对象非空）。</li></ol><p>Java编译器允许处理器乱序执行。上诉的2，3两步的顺序可能被打乱。打乱后，非空判断的线程不安全。在JDK1.5之后，调整了JVM，具体化了<code>volatile</code>关键字，表示此操作是一个原子操作，不能中间被分割执行。使用<code>volatile</code>关键字会影响性能。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// 内部类，包含单例的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公有静态方法用于获取单例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次加载<code>Singleton</code>时，<code>SingletonHolder</code>不会被加载。只用调用<code>getInstance()</code>时，才加载<code>SingletonHolder</code>，并创建<code>INSTANCE</code>。<em>推荐大家使用</em>。</p><h2 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> &#123;</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽说代码简单，<code>enum</code>的实质也是<code>class</code>（编译时，会先翻译成一个class）。优点是反序列化也不会重新生成新的实例。</p><p>前几种方式，如果要避免反序列化也不会重新生成新的实例。需要重写：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Object readResolve() throws ObjectStreamException&#123;</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单例管理类"><a href="#单例管理类" class="headerlink" title="单例管理类"></a>单例管理类</h2><p>一个程序可能有多个单例对象。先建立一个上诉管理类。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class SingletonManager &#123;</span><br><span class="line"><span class="comment">// 容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; objMap = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有构造方法</span></span><br><span class="line"><span class="keyword">private</span> SingletonManager() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> ascendSingleton(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">Object</span> instance) &#123;</span><br><span class="line"><span class="keyword">if</span> (!objMap.containsKey(<span class="built_in">key</span>)) &#123;</span><br><span class="line">objMap.put(<span class="built_in">key</span>, instance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得单例对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Object</span> getInstance(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> objMap.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过注册，可以管理多种类型的单例，使用统一接口，隐藏具体实现。<br>使用时：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册单例</span></span><br><span class="line"><span class="selector-tag">SingletonManager</span><span class="selector-class">.ascendSingleton</span>(<span class="string">"SingletonKey"</span>,Singleton.getInstance());</span><br></pre></td></tr></table></figure></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得单例对象</span></span><br><span class="line">Singleton singleton = SingletonManager.getInstance(<span class="string">"SingletonKey"</span>);</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>只有一个对象，全局使用。</li><li>只需要建立一次，占一个内存，节约资源。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>没有接口，难以扩展。</li><li>生命周期长，如果引用短生命周期对象会内存泄漏。</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>通过<em>Java反射机制</em>是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。</p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>设计模式Demo<br>GitHub源码：<a href="https://github.com/wzmyyj/Design-Pattern" target="_blank" rel="noopener">https://github.com/wzmyyj/Design-Pattern</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单例模式&lt;/strong&gt;（Singleton Pattern）是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://wzmyyj.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】面向对象六大原则</title>
    <link href="http://wzmyyj.top/2018/04/15/design_1/"/>
    <id>http://wzmyyj.top/2018/04/15/design_1/</id>
    <published>2018-04-14T16:08:04.000Z</published>
    <updated>2018-05-30T09:37:50.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><strong>设计模式</strong>（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化。设计模式分为三种类型，分别是：创建型模式、结构型模式，行为型模式。</p><a id="more"></a><h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><ul><li>创建型模式，共5种：<a href="https://www.jianshu.com/p/010bf3bc846e" target="_blank" rel="noopener">单例模式</a>、<a href="https://www.jianshu.com/p/539975502ad1" target="_blank" rel="noopener">工厂模式</a>、<a href="https://www.jianshu.com/p/06fd85ca913b" target="_blank" rel="noopener">抽象工厂模式</a>、建造者模式、原型模式。</li><li>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><h4 id="1，单一职责原则（Single-Responsibility-Principle-SRP）"><a href="#1，单一职责原则（Single-Responsibility-Principle-SRP）" class="headerlink" title="1，单一职责原则（Single Responsibility Principle, SRP）"></a>1，单一职责原则（Single Responsibility Principle, SRP）</h4><p>定义：一个类应只包含单一的职责。</p><ul><li>如果一个类职责过多，代码量就多，而使用起来显得过分冗余，不利于复用。</li><li>如果修改某个职责，可能影响另一个职责。</li></ul><h4 id="2，开放封闭原则-Open-ClosedPrinciple-OCP"><a href="#2，开放封闭原则-Open-ClosedPrinciple-OCP" class="headerlink" title="2，开放封闭原则(Open - ClosedPrinciple ,OCP)"></a>2，开放封闭原则(Open - ClosedPrinciple ,OCP)</h4><p>定义：一个模块、类、函数应当是对修改关闭，对扩展开放。</p><ul><li>修改原有的代码可能会导致原本正常的功能出现问题。</li><li>当需求改变时，最好通过扩展来实现，增加新的方法或类满足需求，而不是去修改原有代码。</li></ul><h4 id="3，里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#3，里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="3，里氏代换原则( Liskov Substitution Principle ,LSP )"></a>3，里氏代换原则( Liskov Substitution Principle ,LSP )</h4><p>定义：使用父类的地方能够使用子类来替换，反过来，则不行。</p><ul><li>使用子类对象去替换父类对象，程序将不会产生错误。</li><li>程序中尽量使用基类类型来对对象进行定义，如父类的子类引用，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li></ul><h4 id="4，依赖倒转原则-Dependence-Inversion-Principle-DIP"><a href="#4，依赖倒转原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="4，依赖倒转原则( Dependence Inversion Principle ,DIP )"></a>4，依赖倒转原则( Dependence Inversion Principle ,DIP )</h4><p>定义：抽象不应该依赖于细节，细节应当依赖于抽象。</p><ul><li>即要面向接口编程，而不是面向具体实现去编程。</li><li>高层模块不应该依赖低层模块，应该去依赖抽象。</li><li>方法定义时，传入对象用抽象类型，实际使用时传入子类对象。</li></ul><h4 id="5，接口隔离法则-Interface-Segregation-Principle，ISL）"><a href="#5，接口隔离法则-Interface-Segregation-Principle，ISL）" class="headerlink" title="5，接口隔离法则(Interface Segregation Principle，ISL）"></a>5，接口隔离法则(Interface Segregation Principle，ISL）</h4><p>定义：一个类对另一个类的依赖应该建立在最小的接口上。</p><ul><li>一个类不应该依赖他不需要的接口，接口的方法全要用得到。</li><li>接口粒度要尽可能小，尽量不能再分割。一个接口的方法过多，可以拆成多个接口。</li></ul><h4 id="6，迪米特法则-Law-of-Demeter-LoD"><a href="#6，迪米特法则-Law-of-Demeter-LoD" class="headerlink" title="6，迪米特法则(Law of Demeter, LoD)"></a>6，迪米特法则(Law of Demeter, LoD)</h4><p>定义：一个类尽量不要与其他类发生关系</p><ul><li>一个类对其他类知道的越少越好，耦合越小。导入的东西越少越好。</li><li>当修改一个类时，其他类的影响就越小，发生错误的可能性就越小。</li></ul><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>设计模式Demo<br>GitHub源码：<a href="https://github.com/wzmyyj/Design-Pattern" target="_blank" rel="noopener">https://github.com/wzmyyj/Design-Pattern</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;设计模式&lt;/strong&gt;（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化。设计模式分为三种类型，分别是：创建型模式、结构型模式，行为型模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://wzmyyj.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【IT】L2TP/IPSec配置教程</title>
    <link href="http://wzmyyj.top/2018/04/10/it_2/"/>
    <id>http://wzmyyj.top/2018/04/10/it_2/</id>
    <published>2018-04-10T13:40:49.000Z</published>
    <updated>2018-06-02T08:40:14.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="L2TP-IPSec"><a href="#L2TP-IPSec" class="headerlink" title="L2TP/IPSec"></a>L2TP/IPSec</h2><p><strong>L2TP</strong>是一种工业标准的Internet隧道协议，功能大致和PPTP协议类似，比如同样可以对网络数据流进行加密。不过也有不同之处，比如PPTP要求网络为IP网络，L2TP要求面向数据包的点对点连接；PPTP使用单一隧道，L2TP使用多隧道；L2TP提供包头压缩、隧道验证，而PPTP不支持。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/3262738-c27da917f2b58a59?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="要不要搭啊"></p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>首先，需要一个境外服务器。我采用的是Vultr服务器（2.5刀每月）。购买方法见我的上篇博客：<a href="https://www.jianshu.com/p/0c8e5e6447bd" target="_blank" rel="noopener">购买Vultr境外服务器</a>。</p><h3 id="配置服务器端"><a href="#配置服务器端" class="headerlink" title="配置服务器端"></a>配置服务器端</h3><p>我们采用的是Github上<a href="https://github.com/hwdsl2/setup-ipsec-vpn" target="_blank" rel="noopener">setup-ipsec-vpn</a>这个脚本安装方法，不需要特别配置，简单安装。</p><h4 id="1-Ubuntu-amp-Debian："><a href="#1-Ubuntu-amp-Debian：" class="headerlink" title="1, Ubuntu &amp; Debian："></a>1, Ubuntu &amp; Debian：</h4><p>1, 远程连接到上诉买的服务器。（默认的用户名是<code>root</code>）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">root</span>@服务器<span class="keyword">ip</span>地址</span><br></pre></td></tr></table></figure><p>这里，下一步会让你输入密码。复制粘贴（右键粘贴，不能Ctrl+v）即可。（控制台上不会显示出密码，粘贴后直接回车即可）</p><p><img src="http://upload-images.jianshu.io/upload_images/3262738-4a27f8dd75caa916?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>等待连接完成。</p><p>2, 刷新一下。复制粘贴下行代码。<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure></p><p>3, 安装脚本。复制粘贴下行代码。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http<span class="variable">s:</span>//git.io/vpnsetup -O vpnsetup.<span class="keyword">sh</span> &amp;&amp; sudo <span class="keyword">sh</span> vpnsetup.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>等待安装完成，需要点点时间。</p><p>安装好后，会自动分配 <code>Username</code>，<code>Password</code>，<code>Pre-Shared key</code>（一些参数，默认是一些随机数。）</p><p>4, 修改参数。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#所有变量值必须用 <span class="string">'单引号'</span> 括起来</span><br><span class="line">#*不要* 在值中使用这些字符：  \ <span class="comment">" ' </span></span><br><span class="line">wget http<span class="variable">s:</span>//git.io/vpnsetup -O vpnsetup.<span class="keyword">sh</span>&amp;&amp;sudo \</span><br><span class="line">VPN_IPSEC_PSK=<span class="string">'你的IPsec预共享密钥'</span>\</span><br><span class="line">VPN_USER=<span class="string">'你的VPN用户名'</span>\</span><br><span class="line">VPN_PASSWORD=<span class="string">'你的VPN密码'</span> <span class="keyword">sh</span> vpnsetup.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><h4 id="2-CentOS-amp-RHEL："><a href="#2-CentOS-amp-RHEL：" class="headerlink" title="2, CentOS &amp; RHEL："></a>2, CentOS &amp; RHEL：</h4><p>首先，更新你的系统。第一步改成：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum update</span></span><br></pre></td></tr></table></figure></p><p>重启。这一步是可选的，但推荐。</p><p>按照与上面相同的步骤，但是</p><blockquote><p>将 <code>https://git.io/vpnsetup</code> 换成 <code>https://git.io/vpnsetup-centos</code>。</p></blockquote><p>到此，你的L2TP/IPSec类型VPN配置完成。</p><h3 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h3><h4 id="1-安卓手机"><a href="#1-安卓手机" class="headerlink" title="1, 安卓手机"></a>1, 安卓手机</h4><p>设置–&gt;连接–&gt;VPN连接–&gt;添加连接–&gt;名称随便取–&gt;类型选L2TP/IPSec PSK–&gt;输入IP地址，预用共享密钥（不是L2TP密钥，未使用的不要填），用户名，密码–&gt;连接（如果第一次连接失败，重试可能仍失败，建议删除连接，重新配置）。</p><h4 id="2-Windows电脑"><a href="#2-Windows电脑" class="headerlink" title="2. Windows电脑"></a>2. Windows电脑</h4><p>打开网络共享中心–&gt;设置新的连接或网络–&gt;连接到工作区–&gt;创建新的连接–&gt;使用我的Internet连接–&gt;填写地址和名称–&gt;填写用户名和密码（域不要填）–&gt;保存连接（不要立刻连接）–&gt;电脑上出现新的连接–&gt;右键–&gt;属性–&gt;安全–&gt;VPN类型（选L2TP/IPSec）–&gt;高级设置–&gt;填写密钥–&gt;保存，连接。</p><p>（不同win版本会有所不同。）</p><h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3, 其他"></a>3, 其他</h4><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度一下，你就知道。</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>连接完成后，你就可以上Google，Facebook，YouTube，Twitter等网站啦。玩韩服七骑士。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;L2TP-IPSec&quot;&gt;&lt;a href=&quot;#L2TP-IPSec&quot; class=&quot;headerlink&quot; title=&quot;L2TP/IPSec&quot;&gt;&lt;/a&gt;L2TP/IPSec&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;L2TP&lt;/strong&gt;是一种工业标准的Internet隧道协议，功能大致和PPTP协议类似，比如同样可以对网络数据流进行加密。不过也有不同之处，比如PPTP要求网络为IP网络，L2TP要求面向数据包的点对点连接；PPTP使用单一隧道，L2TP使用多隧道；L2TP提供包头压缩、隧道验证，而PPTP不支持。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IT" scheme="http://wzmyyj.top/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>【IT】购买Vultr服务器</title>
    <link href="http://wzmyyj.top/2018/04/07/it_1/"/>
    <id>http://wzmyyj.top/2018/04/07/it_1/</id>
    <published>2018-04-07T08:11:50.000Z</published>
    <updated>2018-06-02T08:40:27.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vultr服务器"><a href="#Vultr服务器" class="headerlink" title="Vultr服务器"></a>Vultr服务器</h2><p><strong>Vultr</strong>是一家美国的服务器厂商,这个VPS服务商是按小时收费的。这意味着,架设一台VPS的成本较低。</p><a id="more"></a><p>##购买步骤</p><p>1, 登录官网：<a href="https://www.vultr.com/" target="_blank" rel="noopener">https://www.vultr.com/</a>。注册一个自己的账号。</p><p>2,  确定需要的服务器配置。一般而言，我们只需要最低配置选择$2.5/月（大约15元/月）的即可。（好多可能售完，只有Miami还有$2.5的）。系统选择推荐Ubuntu （16.04或14.04）。</p><p>2.1, 地点</p><p><img src="http://upload-images.jianshu.io/upload_images/3262738-cb519e7612b9d244?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>2.2, 系统</p><p><img src="http://upload-images.jianshu.io/upload_images/3262738-67ad678a266acf51?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>2.3, 附加服务</p><p><img src="http://upload-images.jianshu.io/upload_images/3262738-f916d456ca855a17?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>2.4, 主机名</p><p><img src="http://upload-images.jianshu.io/upload_images/3262738-cda6d55a8926bc71?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>3, 支付。选择支付宝扫码支付。至少支付$10（60多元）。</p><p><img src="http://upload-images.jianshu.io/upload_images/3262738-d5540ab72e625b3b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>4, 购买步骤2选的服务器。</p><p>到此。你的服务器购买完毕。</p><h2 id="管理Vultr服务器"><a href="#管理Vultr服务器" class="headerlink" title="管理Vultr服务器"></a>管理Vultr服务器</h2><p>1, 服务器管理界面。</p><p><img src="http://upload-images.jianshu.io/upload_images/3262738-da941d322e4a8494?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="http://upload-images.jianshu.io/upload_images/3262738-3ffee9cfdca4af80?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p>重点看ID，用户名和密码，以后需要用到。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vultr服务器&quot;&gt;&lt;a href=&quot;#Vultr服务器&quot; class=&quot;headerlink&quot; title=&quot;Vultr服务器&quot;&gt;&lt;/a&gt;Vultr服务器&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Vultr&lt;/strong&gt;是一家美国的服务器厂商,这个VPS服务商是按小时收费的。这意味着,架设一台VPS的成本较低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IT" scheme="http://wzmyyj.top/tags/IT/"/>
    
  </entry>
  
</feed>
