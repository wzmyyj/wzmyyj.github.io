[{"title":"【随笔】我也没有答案","date":"2018-06-05T03:54:29.000Z","path":"2018/06/05/essay_2/","text":"转载，侵删：https://m.llspace.com/v/uc403589 当爱丽丝第一次来到仙境直到最后将要离别的时候她对疯帽子说“我喜欢你”疯帽子问她为什么？她说：“因为乌鸦长得像写字台”疯帽子问：“为什么乌鸦长得像写字台？”爱丽丝：“因为我喜欢你”正当爱丽丝快要离开仙境疯帽子赶忙问道“你会忘了我吗？”“不会，因为乌鸦像写字台”爱丽丝就这么走了“你会忘了我的…”疯帽子望着爱丽丝远去的身影喃喃着他知道喝过遗忘药水的人不会再恢复有关仙境的记忆了【爱上一个人，就像乌鸦像写字台，无需理由】当爱丽丝再次重回仙境这时的她已记不起从前疯帽子见到久违的爱丽丝几乎语无伦次的说道“你绝对是爱丽丝，化成灰我都认识你！”爱丽丝望着眼前的这个陌生人只是觉得他是个十足的疯子他也知道她已没有了记忆但还是兴奋地问道“你知道为什么乌鸦长的像写字台吗？”爱丽丝苦恼的摇了摇头一场大战之后爱丽丝再次拯救了仙境然而又到了离别的时候而这次将是永别这次爱丽丝反问疯帽子“疯帽子，为什么乌鸦会像写字台呢？”疯帽子微笑的看着她久久才说“我也没有答案” 不是同一世界的人就算他再爱着她总有一天也会分开何不就此放手？疯帽子恰恰明白了这一点一句“没有答案”包涵了他太多的勇气 （略有改动） 相关电影：《爱丽丝梦游仙境》 来源《平行世界》APP原文链接","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wzmyyj.top/tags/随笔/"}]},{"title":"【IT】提问的智慧","date":"2018-06-04T14:08:19.000Z","path":"2018/06/04/it_3/","text":"《提问的智慧》艾瑞克.史蒂文.雷蒙德（Eric Steven Raymond）Thyrsus Enterprises &#101;&#115;&#x72;&#x40;&#x74;&#x68;&#121;&#x72;&#x73;&#117;&#115;&#x2e;&#x63;&#x6f;&#x6d;瑞克.莫恩（Rick Moen） &#x72;&#x65;&#x73;&#112;&#x6f;&#110;&#100;&#x2d;&#97;&#117;&#x74;&#111;&#x40;&#108;&#105;&#110;&#x75;&#x78;&#109;&#97;&#x66;&#x69;&#x61;&#x2e;&#x63;&#x6f;&#109;版权©2001, 2006 Eric S. Raymond, Rick Moen 传送门中文：《提问的智慧》 原文：《How To Ask Questions The Smart Way》 要求声明：（我们不提供该项目的服务支持！）","tags":[{"name":"IT","slug":"IT","permalink":"http://wzmyyj.top/tags/IT/"}]},{"title":"【随笔】小蚂蚁的抉择","date":"2018-06-04T03:54:19.000Z","path":"2018/06/04/essay_1/","text":"故事一天，一只小蚂蚁，来到一个三叉路口。 左边的路过去，会有一块香甜的奶酪。但是，路的另一端，有一只更大的蚂蚁正在慢慢靠近，虽然它的距离更远些。也就是说，如果过去吃奶酪，只能吃上几口，然后需要与大蚂蚁打一架，决定是否得到剩余的大半奶酪。 右边的路过去，在更远的一处，也有一块类似的奶酪。但是，没法确定那边是否有其他蚂蚁。如果有，也不确定是否比自己大，是否打得过它。 那时，… 小蚂蚁没有过去，而是回头去了别的地方。到了别的地方，小蚂蚁发现了一块能吃了可以慢慢变回来的奶酪。小蚂蚁高兴的品尝着这份甜蜜，吃得差不多了，先把剩下的留着，它会自己慢慢变回来。此后，小蚂蚁一次往往只过一段时间吃几口。 最后，… 有那么一天，奶酪被命运夺走了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wzmyyj.top/tags/随笔/"}]},{"title":"【图片】一些动漫图片","date":"2018-06-01T13:20:06.000Z","path":"2018/06/01/pic_1/","text":"","tags":[{"name":"图片","slug":"图片","permalink":"http://wzmyyj.top/tags/图片/"}]},{"title":"【android】封装使用Toast","date":"2018-05-22T12:57:43.000Z","path":"2018/05/22/android_2/","text":"android.widget.Toast类Toast是Android中用来显示显示信息的一种机制，和Dialog不一样的是，Toast是没有焦点的，而且Toast显示的时间有限，过一定的时间就会自动消失。而且Toast主要用于向用户显示提示消息。 1,常规用法123Toast.makeText(context, \"一条消息\", Toast.LENGTH_SHORT).show();// 或Toast.makeText(context, \"一条消息\", Toast.LENGTH_LONG).show(); 其中context是上下文。 虽然只需要一行代码，但写起来并不方便。做个简单封装吧。 2,封装Toast123456789101112131415161718192021222324252627282930public class T &#123; private static Application app; private T() &#123; &#125; public static void init(Application app) &#123; T.app = app; &#125; public static void s(String msg) &#123; if (app == null) return; s(app, msg); &#125; public static void l(String msg) &#123; if (app == null) return; l(app, msg); &#125; public static void s(Context context, String msg) &#123; Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); &#125; public static void l(Context context, String msg) &#123; Toast.makeText(context, msg, Toast.LENGTH_LONG).show(); &#125;&#125; 使用时，先在自己写的Application中初始化。1234567public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); T.init(this); &#125;&#125; 使用时，只需：123T.s(\"一条消息\");// 时间较短 //或T.l(\"一条消息\");// 时间较长 如果没有在Application中初始化。也可以：123T.s(context,\"一条消息\");// 时间较短 //或T.l(context,\"一条消息\");// 时间较长 虽然T的命名是不规范的，但是用起来真是方便。当它比较特殊常用就好啦。 其他还有对Log的简单封装：Android中的Log类","tags":[{"name":"android","slug":"android","permalink":"http://wzmyyj.top/tags/android/"}]},{"title":"【android】Android中的Log类","date":"2018-05-22T12:43:30.000Z","path":"2018/05/22/android_1/","text":"android.util.Log类android.util.Log常用的方法有以下5个：Log.v()， Log.d() ，Log.i() ，Log.w() 以及 Log.e() 。根据首字母对应VERBOSE，DEBUG，INFO， WARN，ERROR。 Log.v 的输出颜色为黑色的，任何消息都会输出，这里的v代表verbose啰嗦的意思。 Log.d的输出颜色为蓝色的，仅输出debug调试的意思，但他会输出上层的信息，过滤起来可以通过DDMS的Logcat标签来选择。 Log.i的输出颜色为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息。 Log.w的输出颜色为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。 Log.e的输出颜色为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。 1,常规用法12345Log.v(TAG,\"一条啰嗦日志\");Log.d(TAG,\"一条调试日志\");Log.i(TAG,\"一条提示日志\");Log.w(TAG,\"一条警告日志\");Log.e(TAG,\"一条错误日志\"); 其中TAG为字符串。用于标记。同一个应用TAG基本可以成一样。并且，应用打包发布时，最好把全部Log注释掉，否则将产生不必要的资源消耗（虽然很小）。 2,分装Log123456789101112131415161718192021222324252627282930313233343536373839404142public class L &#123; private static String TAG = \"WZM\"; // 开关 private static boolean debug = true; private L() &#123; &#125; public static void setTAG(String TAG) &#123; L.TAG = TAG; &#125; public static void setDebug(boolean debug) &#123; L.debug = debug; &#125; public static void v(String msg) &#123; if (debug) Log.v(TAG, msg); &#125; public static void d(String msg) &#123; if (debug) Log.d(TAG, msg); &#125; public static void i(String msg) &#123; if (debug) Log.i(TAG, msg); &#125; public static void w(String msg) &#123; if (debug) Log.w(TAG, msg); &#125; public static void e(String msg) &#123; if (debug) Log.e(TAG, msg); &#125;&#125; 使用时：12345L.v(\"一条啰嗦日志\");L.d(\"一条调试日志\");L.i(\"一条提示日志\");L.w(\"一条警告日志\");L.e(\"一条错误日志\"); 并且，可在Application中设置开关（是否输出日志）或TAG（默认WZM）12345678public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); L.setTAG(\"TAG\"); L.setDebug(false); &#125;&#125; 打包发布时，debug设为false即可。 其他还有对Toast的简单封装：Android 封装Toast","tags":[{"name":"android","slug":"android","permalink":"http://wzmyyj.top/tags/android/"}]},{"title":"【设计模式】工厂模式","date":"2018-05-18T09:52:10.000Z","path":"2018/05/18/design_3/","text":"工厂模式工厂模式（Factory Pattern）就是专门负责将大量有共同接口的类实例化，而且不必事先知道每次是要实例化哪一个类的模式。它定义一个用于创建对象的接口，由子类决定实例化哪一个类。工厂模式相当于创建实例对象的new，经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的。 UML类图 抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。 具体产品类（ProductX）：实现基类中的抽象方法（多个不同的具体产品，X=1,2,3..）。 抽象工厂类或接口（AbstractFactory）：定义具体工厂的公共接口。 具体工厂类（FactoryX）：定义创建对应具体产品实例的方法。（每个工厂对应一种具体产品，X=1,2,3…）。 案例分析既然是工厂，当然是要生产产品。那我们来造什么好呢？，，嗯，，，造小孩？NO，NO，NO！我们还是来造英雄吧。 场景：玩《英雄联盟》（5v5 moba端游）新开一局游戏，游戏开始每个玩家需要选一个信赖的英雄。选好后，英雄会很兴奋，说一句专属的台词。那么程序上是new出该英雄的对象，执行该对象的say()方法。 常规写法：建立英雄类：123456public abstract class Hero &#123; protected String name; public abstract void say();&#125; 寒冰射手-艾希类（继承Hero类）：1234567891011121314public class Ashe extends Hero &#123; // 简化构造方法，只弄个名字。 public Ashe() &#123; this.name = \"寒冰射手-艾希\"; &#125; // 艾希台词 // 艾希台词 @Override public void say() &#123; System.out.println(name + \"：\" + \"世间万物皆系于一箭之上。\"); &#125;&#125; 类似的写了亚索类，光辉类，盖伦类，剑圣类（全部英雄的话，还有好多）。再写个枚举（可以不需要，仅仅拿来当对应标识使用）。1234567public enum Who &#123; Ashe, Garen, Yi, Lux, Yasuo&#125; 然后客户端调用：（菜鸟写法）1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Client1 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 Ashe ashe = new Ashe(); ashe.say(); break; case Yasuo: // 亚索 Yasuo yasuo = new Yasuo(); yasuo.say(); break; case Garen: // 德玛 Garen garen = new Garen(); garen.say(); break; case Lux: // 光辉 Lux lux = new Lux(); lux.say(); break; case Yi: // 剑圣 Yi yi = new Yi(); yi.say(); break; &#125; &#125;&#125; 客户端调用：（好学生写法，父类的子类引用）123456789101112131415161718192021222324252627282930313233public class Client2 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); Hero hero = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 hero = new Ashe(); break; case Yasuo: // 亚索 hero = new Yasuo(); break; case Garen: // 德玛 hero = new Garen(); break; case Lux: // 光辉 hero = new Lux(); break; case Yi: // 剑圣 hero = new Yi(); break; &#125; hero.say(); &#125;&#125; 这里客户端需要知道： 英雄怎么构造，怎么new出来。（事实上英雄的构造远没有这么简单。） 每个英雄的方法怎么调用。（这里都是say()方法） 我们前面提到，利用工厂可以把创建对象的过程封装掉，客户端只要知道得到对象后调用其方法即可。用工厂代替new的过程。那就看看工厂方法怎么去实现吧。 工厂模式写法先建立一个工厂类的接口：1234public interface Factory &#123; //创建英雄的接口 public abstract Hero create();&#125; 然后建立不同英雄对应的工厂实现类。比如艾希工厂：123456public class AsheFactory implements Factory &#123; //实现具体的创建英雄的方法。 public Hero create() &#123; return new Ashe(); &#125;&#125; 同样的建立亚索工厂，光辉工厂，盖伦工厂，剑圣工厂等。 然后客户端调用：12345678910111213141516171819202122232425262728293031323334public class Client3 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); Factory factory = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希工厂 factory = new AsheFactory(); break; case Yasuo: // 亚索工厂 factory = new YasuoFactory(); break; case Garen: // 德玛工厂 factory = new GarenFactory(); break; case Lux: // 光辉工厂 factory = new LuxFactory(); break; case Yi: // 剑圣工厂 factory = new YiFactory(); break; &#125; Hero hero = factory.create(); hero.say(); &#125;&#125; switch中不再是英雄的创建过程，而是选择英雄工厂的过程。根据不同name选择不同的工厂，然后由工厂去实例化具体英雄对象。 新增一个英雄，就新增一个对应的工厂。需要修改的只有客户端代码。 如果不需要新增也不需要减少。我们是不是可以把工厂的选择封装起来。让多家工厂合并成一家工厂。那就是接下来要讲的简单工厂模式 简单工厂模式简单工厂模式（Simple Factory Pattern）是类的创建模式，又叫做静态工厂方法模式。就是由一个工厂类根据传入的参量决定创建出哪一种产品类的实例。与上面工厂模式的区别就是它只需要一个工厂。 UML类图 抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。 具体产品类（ConcreteProduct）：实现基类中的抽象方法。 工厂类（Factory）：用以封装实例化对象过程，根据传入的参数决定生产不同的产品。 利用简单工厂的写法：其他地方不变，将工厂合并成一个工厂类，并在内部写个静态方法，根据传入的参数决定创建不同的英雄对象：12345678910111213141516171819202122232425262728293031public class SimpleFactory &#123; public static Hero create(String name) &#123; Hero hero = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 hero = new Ashe(); break; case Yasuo: // 亚索 hero = new Yasuo(); break; case Garen: // 德玛 hero = new Garen(); break; case Lux: // 光辉 hero = new Lux(); break; case Yi: // 剑圣 hero= new Yi(); break; &#125; return hero; &#125;&#125; 客户端代码做简单修改：12345678910public class Client4 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); // 根据传入的名字构建不同的英雄。 Hero hero = SimpleFactory.create(name); hero.say(); &#125;&#125; 客户端不需要知道对象的构建过程，只要传入参数得到不同对象。 但是简单工厂是固定的，如果增减英雄他就要修改。不符合开闭原则。这时候用前面工厂模式好，把修改转移给客户端，而不修改工厂代码。 结果选个盖伦试试： 不能浪，不能浪。 抽象工厂模式请看下篇【设计模式】抽象工厂模式。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wzmyyj.top/tags/设计模式/"}]},{"title":"【设计模式】单例模式","date":"2018-04-17T13:20:06.000Z","path":"2018/04/17/design_2/","text":"单例模式单例模式（Singleton Pattern）是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。 某个类只能有一个实例。 它必须自行创建这个实例。 它必须自行向整个系统提供这个实例。 单例模式关键点： 构造函数私有化（不让外部创建此类对象）。 通过一个静态方法或枚举返回单例类对象。 多线程环境下，确保单例（难点）。 反序列化不会重新构建对象。 饿汉式12345678910111213141516171819public class Singleton &#123; // 单例对象 private final static Singleton INSTANCE = new Singleton(); // 或 // private final static Singleton INSTANCE; // static &#123; // INSTANCE = new Singleton(); // &#125; // 私有构造方法 private Singleton() &#123; &#125; // 公有静态方法用于获取单例对象 public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 线程安全。但是没使用它时，就已经建立了对象，开销内存。 懒汉式12345678910111213141516public class Singleton &#123; // 单例对象 private static Singleton INSTANCE = null; // 私有构造方法 private Singleton() &#123; &#125; // synchronized关键字修饰静态方法 public static synchronized Singleton getInstance() &#123; if (null == INSTANCE) &#123;// 空值判断 INSTANCE = new Singleton(); &#125; return INSTANCE; &#125;&#125; 在第一次调用getInstance()时，创建单例对象。synchronized关键字修饰，使getInstance()是一个同步方法。保证多线程情况下单例对象的唯一。但是，同步会耗费资源。 双检锁式（Double Check Lock（DCL））1234567891011121314151617181920public class Singleton &#123; // 单例对象，volatile关键字保证INSTANCE的原子性 private volatile static Singleton INSTANCE = null; // 私有构造方法 private Singleton() &#123; &#125; // 两次空值检查，synchronized关键字同步 public static Singleton getInstance() &#123; if (null == INSTANCE) &#123; synchronized (Singleton.class) &#123; if (null == INSTANCE) &#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 语句INSTANCE = new Singleton();在编译时的步骤如下： 给Singleton的实例分配内存。 调用Singleton()的构造函数，初始化成员字段。 将INSTANCE 对象指向分配的内存空间（此时对象非空）。 Java编译器允许处理器乱序执行。上诉的2，3两步的顺序可能被打乱。打乱后，非空判断的线程不安全。在JDK1.5之后，调整了JVM，具体化了volatile关键字，表示此操作是一个原子操作，不能中间被分割执行。使用volatile关键字会影响性能。 静态内部类123456789101112131415public class Singleton &#123; // 内部类，包含单例的对象 private static class SingletonHolder &#123; public static final Singleton INSTANCE = new Singleton(); &#125; // 私有构造方法 private Singleton() &#123; &#125; // 公有静态方法用于获取单例对象 public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 第一次加载Singleton时，SingletonHolder不会被加载。只用调用getInstance()时，才加载SingletonHolder，并创建INSTANCE。推荐大家使用。 枚举式123public enum SingletonEnum &#123; INSTANCE;&#125; 虽说代码简单，enum的实质也是class（编译时，会先翻译成一个class）。优点是反序列化也不会重新生成新的实例。 前几种方式，如果要避免反序列化也不会重新生成新的实例。需要重写：123private Object readResolve() throws ObjectStreamException&#123; return INSTANCE;&#125; 单例管理类一个程序可能有多个单例对象。先建立一个上诉管理类。1234567891011121314151617181920public class SingletonManager &#123; // 容器 private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String, Object&gt;(); // 私有构造方法 private SingletonManager() &#123; &#125; // 注册单例 public static void ascendSingleton(String key, Object instance) &#123; if (!objMap.containsKey(key)) &#123; objMap.put(key, instance); &#125; &#125; // 获得单例对象 public static Object getInstance(String key) &#123; return objMap.get(key); &#125;&#125; 通过注册，可以管理多种类型的单例，使用统一接口，隐藏具体实现。使用时：12//注册单例SingletonManager.ascendSingleton(\"SingletonKey\",Singleton.getInstance()); 12//获得单例对象Singleton singleton = SingletonManager.getInstance(\"SingletonKey\"); 优点 只有一个对象，全局使用。 只需要建立一次，占一个内存，节约资源。 缺点 没有接口，难以扩展。 生命周期长，如果引用短生命周期对象会内存泄漏。 补充通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wzmyyj.top/tags/设计模式/"}]},{"title":"【设计模式】面向对象六大原则","date":"2018-04-14T16:08:04.000Z","path":"2018/04/15/design_1/","text":"设计模式设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化。设计模式分为三种类型，分别是：创建型模式、结构型模式，行为型模式。 23种设计模式 创建型模式，共5种：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 六大原则1，单一职责原则（Single Responsibility Principle, SRP）定义：一个类应只包含单一的职责。 如果一个类职责过多，代码量就多，而使用起来显得过分冗余，不利于复用。 如果修改某个职责，可能影响另一个职责。 2，开放封闭原则(Open - ClosedPrinciple ,OCP)定义：一个模块、类、函数应当是对修改关闭，对扩展开放。 修改原有的代码可能会导致原本正常的功能出现问题。 当需求改变时，最好通过扩展来实现，增加新的方法或类满足需求，而不是去修改原有代码。 3，里氏代换原则( Liskov Substitution Principle ,LSP )定义：使用父类的地方能够使用子类来替换，反过来，则不行。 使用子类对象去替换父类对象，程序将不会产生错误。 程序中尽量使用基类类型来对对象进行定义，如父类的子类引用，而在运行时再确定其子类类型，用子类对象来替换父类对象。 4，依赖倒转原则( Dependence Inversion Principle ,DIP )定义：抽象不应该依赖于细节，细节应当依赖于抽象。 即要面向接口编程，而不是面向具体实现去编程。 高层模块不应该依赖低层模块，应该去依赖抽象。 方法定义时，传入对象用抽象类型，实际使用时传入子类对象。 5，接口隔离法则(Interface Segregation Principle，ISL）定义：一个类对另一个类的依赖应该建立在最小的接口上。 一个类不应该依赖他不需要的接口，接口的方法全要用得到。 接口粒度要尽可能小，尽量不能再分割。一个接口的方法过多，可以拆成多个接口。 6，迪米特法则(Law of Demeter, LoD)定义：一个类尽量不要与其他类发生关系 一个类对其他类知道的越少越好，耦合越小。导入的东西越少越好。 当修改一个类时，其他类的影响就越小，发生错误的可能性就越小。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wzmyyj.top/tags/设计模式/"}]},{"title":"【java】归并排序算法","date":"2018-04-14T13:35:08.000Z","path":"2018/04/14/java_1/","text":"归并排序归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序算法稳定，数组需要O(n)的额外空间，链表需要O(log(n))的额外空间，时间复杂度为O(nlog(n))，算法不是自适应的，不需要对数据的随机读取。 工作原理 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。 设定两个指针，最初位置分别为两个已经排序序列的起始位置。 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。 重复步骤3直到某一指针达到序列尾。 将另一序列剩下的所有元素直接复制到合并序列尾。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class MergeSortTest &#123; public static void main(String[] args) &#123; //测试数据 int A[] = &#123; 1, 6, 4, 5, 2, 9, 7, 23, 56, 43, 99 &#125;; // 排序前 System.out.println(\"排序前：\"); for (int a : A) &#123; System.out.print(a + \" \"); &#125; System.out.println(); // 排序 mergeSort(A); // 排序后 System.out.println(\"排序后：\"); for (int a : A) &#123; System.out.print(a + \" \"); &#125; System.out.println(); &#125; // 排序入口 public static void mergeSort(int[] A) &#123; sort(A, 0, A.length - 1); &#125; //递归 public static void sort(int[] A, int start, int end) &#123; if (start &gt;= end) return; // 找出中间索引 int mid = (start + end) / 2; // 对左边数组进行递归 sort(A, start, mid); // 对右边数组进行递归 sort(A, mid + 1, end); // 合并 merge(A, start, mid, end); &#125; // 将两个数组进行归并，归并前面2个数组已有序，归并后依然有序 public static void merge(int[] A, int start, int mid, int end) &#123; int[] temp = new int[A.length];// 临时数组 int k = 0; int i = start; int j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; // 从两个数组中取出较小的放入临时数组 if (A[i] &lt;= A[j]) &#123; temp[k++] = A[i++]; &#125; else &#123; temp[k++] = A[j++]; &#125; &#125; // 剩余部分依次放入临时数组（实际上两个while只会执行其中一个） while (i &lt;= mid) &#123; temp[k++] = A[i++]; &#125; while (j &lt;= end) &#123; temp[k++] = A[j++]; &#125; // 将临时数组中的内容拷贝回原数组中 （left-right范围的内容） for (int m = 0; m &lt; k; m++) &#123; A[m + start] = temp[m]; &#125; &#125;&#125; 对于算法，理解原理很重要。。。 附页GitHub源码：https://github.com/wzmyyj/MergeSort","tags":[{"name":"java","slug":"java","permalink":"http://wzmyyj.top/tags/java/"}]},{"title":"【IT】L2TP/IPSec配置教程","date":"2018-04-10T13:40:49.000Z","path":"2018/04/10/it_2/","text":"L2TP/IPSecL2TP是一种工业标准的Internet隧道协议，功能大致和PPTP协议类似，比如同样可以对网络数据流进行加密。不过也有不同之处，比如PPTP要求网络为IP网络，L2TP要求面向数据包的点对点连接；PPTP使用单一隧道，L2TP使用多隧道；L2TP提供包头压缩、隧道验证，而PPTP不支持。 服务器首先，需要一个境外服务器。我采用的是Vultr服务器（2.5刀每月）。购买方法见我的上篇博客：购买Vultr境外服务器。 配置服务器端我们采用的是Github上setup-ipsec-vpn这个脚本安装方法，不需要特别配置，简单安装。 1, Ubuntu &amp; Debian：1, 远程连接到上诉买的服务器。（默认的用户名是root） 1ssh root@服务器ip地址 这里，下一步会让你输入密码。复制粘贴（右键粘贴，不能Ctrl+v）即可。（控制台上不会显示出密码，粘贴后直接回车即可） 等待连接完成。 2, 刷新一下。复制粘贴下行代码。1sudo apt-get update 3, 安装脚本。复制粘贴下行代码。 1wget https://git.io/vpnsetup -O vpnsetup.sh &amp;&amp; sudo sh vpnsetup.sh 等待安装完成，需要点点时间。 安装好后，会自动分配 Username，Password，Pre-Shared key（一些参数，默认是一些随机数。） 4, 修改参数。 123456#所有变量值必须用 '单引号' 括起来#*不要* 在值中使用这些字符： \\ \" ' wget https://git.io/vpnsetup -O vpnsetup.sh&amp;&amp;sudo \\VPN_IPSEC_PSK='你的IPsec预共享密钥'\\VPN_USER='你的VPN用户名'\\VPN_PASSWORD='你的VPN密码' sh vpnsetup.sh 2, CentOS &amp; RHEL：首先，更新你的系统。第一步改成：1yum update 重启。这一步是可选的，但推荐。 按照与上面相同的步骤，但是 将 https://git.io/vpnsetup 换成 https://git.io/vpnsetup-centos。 到此，你的L2TP/IPSec类型VPN配置完成。 配置客户端1, 安卓手机设置–&gt;连接–&gt;VPN连接–&gt;添加连接–&gt;名称随便取–&gt;类型选L2TP/IPSec PSK–&gt;输入IP地址，预用共享密钥（不是L2TP密钥，未使用的不要填），用户名，密码–&gt;连接（如果第一次连接失败，重试可能仍失败，建议删除连接，重新配置）。 2, Windows电脑打开网络共享中心–&gt;设置新的连接或网络–&gt;连接到工作区–&gt;创建新的连接–&gt;使用我的Internet连接–&gt;填写地址和名称–&gt;填写用户名和密码（域不要填）–&gt;保存连接（不要立刻连接）–&gt;电脑上出现新的连接–&gt;右键–&gt;属性–&gt;安全–&gt;VPN类型（选L2TP/IPSec）–&gt;高级设置–&gt;填写密钥–&gt;保存，连接。 （不同win版本会有所不同。） 3, 其他百度一下，你就知道。 作用连接完成后，你就可以上Google，Facebook，YouTube，Twitter等网站啦。玩韩服七骑士。","tags":[{"name":"IT","slug":"IT","permalink":"http://wzmyyj.top/tags/IT/"}]},{"title":"【IT】购买Vultr服务器","date":"2018-04-07T08:11:50.000Z","path":"2018/04/07/it_1/","text":"Vultr服务器Vultr是一家美国的服务器厂商,这个VPS服务商是按小时收费的。这意味着,架设一台VPS的成本较低。 ##购买步骤 1, 登录官网：https://www.vultr.com/。注册一个自己的账号。 2, 确定需要的服务器配置。一般而言，我们只需要最低配置选择$2.5/月（大约15元/月）的即可。（好多可能售完，只有Miami还有$2.5的）。系统选择推荐Ubuntu （16.04或14.04）。 2.1, 地点 2.2, 系统 2.3, 附加服务 2.4, 主机名 3, 支付。选择支付宝扫码支付。至少支付$10（60多元）。 4, 购买步骤2选的服务器。 到此。你的服务器购买完毕。 管理Vultr服务器1, 服务器管理界面。 重点看ID，用户名和密码，以后需要用到。","tags":[{"name":"IT","slug":"IT","permalink":"http://wzmyyj.top/tags/IT/"}]}]