[{"title":"【图片】一些动漫图片","date":"2018-06-01T13:20:06.000Z","path":"2018/06/01/【图片】一些动漫图片/","text":"","tags":[{"name":"图片","slug":"图片","permalink":"http://wzmyyj.top/tags/图片/"}]},{"title":"【设计模式】工厂模式","date":"2018-05-18T09:52:10.000Z","path":"2018/05/18/【设计模式】工厂模式/","text":"工厂模式工厂模式（Factory Pattern）就是专门负责将大量有共同接口的类实例化，而且不必事先知道每次是要实例化哪一个类的模式。它定义一个用于创建对象的接口，由子类决定实例化哪一个类。工厂模式相当于创建实例对象的new，经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的。 UML类图 抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。 具体产品类（ProductX）：实现基类中的抽象方法（多个不同的具体产品，X=1,2,3..）。 抽象工厂类或接口（AbstractFactory）：定义具体工厂的公共接口。 具体工厂类（FactoryX）：定义创建对应具体产品实例的方法。（每个工厂对应一种具体产品，X=1,2,3…）。 案例分析既然是工厂，当然是要生产产品。那我们来造什么好呢？，，嗯，，，造小孩？NO，NO，NO！我们还是来造英雄吧。 场景：玩《英雄联盟》（5v5 moba端游）新开一局游戏，游戏开始每个玩家需要选一个信赖的英雄。选好后，英雄会很兴奋，说一句专属的台词。那么程序上是new出该英雄的对象，执行该对象的say()方法。 常规写法：建立英雄类：123456public abstract class Hero &#123; protected String name; public abstract void say();&#125; 寒冰射手-艾希类（继承Hero类）：1234567891011121314public class Ashe extends Hero &#123; // 简化构造方法，只弄个名字。 public Ashe() &#123; this.name = \"寒冰射手-艾希\"; &#125; // 艾希台词 // 艾希台词 @Override public void say() &#123; System.out.println(name + \"：\" + \"世间万物皆系于一箭之上。\"); &#125;&#125; 类似的写了亚索类，光辉类，盖伦类，剑圣类（全部英雄的话，还有好多）。再写个枚举（可以不需要，仅仅拿来当对应标识使用）。1234567public enum Who &#123; Ashe, Garen, Yi, Lux, Yasuo&#125; 然后客户端调用：（菜鸟写法）1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Client1 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 Ashe ashe = new Ashe(); ashe.say(); break; case Yasuo: // 亚索 Yasuo yasuo = new Yasuo(); yasuo.say(); break; case Garen: // 德玛 Garen garen = new Garen(); garen.say(); break; case Lux: // 光辉 Lux lux = new Lux(); lux.say(); break; case Yi: // 剑圣 Yi yi = new Yi(); yi.say(); break; &#125; &#125;&#125; 客户端调用：（好学生写法，父类的子类引用）123456789101112131415161718192021222324252627282930313233public class Client2 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); Hero hero = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 hero = new Ashe(); break; case Yasuo: // 亚索 hero = new Yasuo(); break; case Garen: // 德玛 hero = new Garen(); break; case Lux: // 光辉 hero = new Lux(); break; case Yi: // 剑圣 hero = new Yi(); break; &#125; hero.say(); &#125;&#125; 这里客户端需要知道： 英雄怎么构造，怎么new出来。（事实上英雄的构造远没有这么简单。） 每个英雄的方法怎么调用。（这里都是say()方法） 我们前面提到，利用工厂可以把创建对象的过程封装掉，客户端只要知道得到对象后调用其方法即可。用工厂代替new的过程。那就看看工厂方法怎么去实现吧。 工厂模式写法先建立一个工厂类的接口：1234public interface Factory &#123; //创建英雄的接口 public abstract Hero create();&#125; 然后建立不同英雄对应的工厂实现类。比如艾希工厂：123456public class AsheFactory implements Factory &#123; //实现具体的创建英雄的方法。 public Hero create() &#123; return new Ashe(); &#125;&#125; 同样的建立亚索工厂，光辉工厂，盖伦工厂，剑圣工厂等。 然后客户端调用：12345678910111213141516171819202122232425262728293031323334public class Client3 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); Factory factory = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希工厂 factory = new AsheFactory(); break; case Yasuo: // 亚索工厂 factory = new YasuoFactory(); break; case Garen: // 德玛工厂 factory = new GarenFactory(); break; case Lux: // 光辉工厂 factory = new LuxFactory(); break; case Yi: // 剑圣工厂 factory = new YiFactory(); break; &#125; Hero hero = factory.create(); hero.say(); &#125;&#125; switch中不再是英雄的创建过程，而是选择英雄工厂的过程。根据不同name选择不同的工厂，然后由工厂去实例化具体英雄对象。 新增一个英雄，就新增一个对应的工厂。需要修改的只有客户端代码。 如果不需要新增也不需要减少。我们是不是可以把工厂的选择封装起来。让多家工厂合并成一家工厂。那就是接下来要讲的简单工厂模式 简单工厂模式简单工厂模式（Simple Factory Pattern）是类的创建模式，又叫做静态工厂方法模式。就是由一个工厂类根据传入的参量决定创建出哪一种产品类的实例。与上面工厂模式的区别就是它只需要一个工厂。 UML类图 抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。 具体产品类（ConcreteProduct）：实现基类中的抽象方法。 工厂类（Factory）：用以封装实例化对象过程，根据传入的参数决定生产不同的产品。 利用简单工厂的写法：其他地方不变，将工厂合并成一个工厂类，并在内部写个静态方法，根据传入的参数决定创建不同的英雄对象：12345678910111213141516171819202122232425262728293031public class SimpleFactory &#123; public static Hero create(String name) &#123; Hero hero = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 hero = new Ashe(); break; case Yasuo: // 亚索 hero = new Yasuo(); break; case Garen: // 德玛 hero = new Garen(); break; case Lux: // 光辉 hero = new Lux(); break; case Yi: // 剑圣 hero= new Yi(); break; &#125; return hero; &#125;&#125; 客户端代码做简单修改：12345678910public class Client4 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); // 根据传入的名字构建不同的英雄。 Hero hero = SimpleFactory.create(name); hero.say(); &#125;&#125; 客户端不需要知道对象的构建过程，只要传入参数得到不同对象。 但是简单工厂是固定的，如果增减英雄他就要修改。不符合开闭原则。这时候用前面工厂模式好，把修改转移给客户端，而不修改工厂代码。 结果选个盖伦试试： 不能浪，不能浪。 抽象工厂模式请看下篇【设计模式】抽象工厂模式。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wzmyyj.top/tags/设计模式/"}]},{"title":"【设计模式】单例模式","date":"2018-04-17T13:20:06.000Z","path":"2018/04/17/【设计模式】单例模式/","text":"单例模式单例模式（Singleton Pattern）是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。 某个类只能有一个实例。 它必须自行创建这个实例。 它必须自行向整个系统提供这个实例。 单例模式关键点： 构造函数私有化（不让外部创建此类对象）。 通过一个静态方法或枚举返回单例类对象。 多线程环境下，确保单例（难点）。 反序列化不会重新构建对象。 饿汉式12345678910111213141516171819public class Singleton &#123; // 单例对象 private final static Singleton INSTANCE = new Singleton(); // 或 // private final static Singleton INSTANCE; // static &#123; // INSTANCE = new Singleton(); // &#125; // 私有构造方法 private Singleton() &#123; &#125; // 公有静态方法用于获取单例对象 public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 线程安全。但是没使用它时，就已经建立了对象，开销内存。 懒汉式12345678910111213141516public class Singleton &#123; // 单例对象 private static Singleton INSTANCE = null; // 私有构造方法 private Singleton() &#123; &#125; // synchronized关键字修饰静态方法 public static synchronized Singleton getInstance() &#123; if (null == INSTANCE) &#123;// 空值判断 INSTANCE = new Singleton(); &#125; return INSTANCE; &#125;&#125; 在第一次调用getInstance()时，创建单例对象。synchronized关键字修饰，使getInstance()是一个同步方法。保证多线程情况下单例对象的唯一。但是，同步会耗费资源。 双检锁式（Double Check Lock（DCL））1234567891011121314151617181920public class Singleton &#123; // 单例对象，volatile关键字保证INSTANCE的原子性 private volatile static Singleton INSTANCE = null; // 私有构造方法 private Singleton() &#123; &#125; // 两次空值检查，synchronized关键字同步 public static Singleton getInstance() &#123; if (null == INSTANCE) &#123; synchronized (Singleton.class) &#123; if (null == INSTANCE) &#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 语句INSTANCE = new Singleton();在编译时的步骤如下： 给Singleton的实例分配内存。 调用Singleton()的构造函数，初始化成员字段。 将INSTANCE 对象指向分配的内存空间（此时对象非空）。 Java编译器允许处理器乱序执行。上诉的2，3两步的顺序可能被打乱。打乱后，非空判断的线程不安全。在JDK1.5之后，调整了JVM，具体化了volatile关键字，表示此操作是一个原子操作，不能中间被分割执行。使用volatile关键字会影响性能。 静态内部类123456789101112131415public class Singleton &#123; // 内部类，包含单例的对象 private static class SingletonHolder &#123; public static final Singleton INSTANCE = new Singleton(); &#125; // 私有构造方法 private Singleton() &#123; &#125; // 公有静态方法用于获取单例对象 public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 第一次加载Singleton时，SingletonHolder不会被加载。只用调用getInstance()时，才加载SingletonHolder，并创建INSTANCE。推荐大家使用。 枚举式123public enum SingletonEnum &#123; INSTANCE;&#125; 虽说代码简单，enum的实质也是class（编译时，会先翻译成一个class）。优点是反序列化也不会重新生成新的实例。 前几种方式，如果要避免反序列化也不会重新生成新的实例。需要重写：123private Object readResolve() throws ObjectStreamException&#123; return INSTANCE;&#125; 单例管理类一个程序可能有多个单例对象。先建立一个上诉管理类。1234567891011121314151617181920public class SingletonManager &#123; // 容器 private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String, Object&gt;(); // 私有构造方法 private SingletonManager() &#123; &#125; // 注册单例 public static void ascendSingleton(String key, Object instance) &#123; if (!objMap.containsKey(key)) &#123; objMap.put(key, instance); &#125; &#125; // 获得单例对象 public static Object getInstance(String key) &#123; return objMap.get(key); &#125;&#125; 通过注册，可以管理多种类型的单例，使用统一接口，隐藏具体实现。使用时：12//注册单例SingletonManager.ascendSingleton(\"SingletonKey\",Singleton.getInstance()); 12//获得单例对象Singleton singleton = SingletonManager.getInstance(\"SingletonKey\"); 优点 只有一个对象，全局使用。 只需要建立一次，占一个内存，节约资源。 缺点 没有接口，难以扩展。 生命周期长，如果引用短生命周期对象会内存泄漏。 补充通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wzmyyj.top/tags/设计模式/"}]},{"title":"【设计模式】面向对象六大原则","date":"2018-04-14T16:08:04.000Z","path":"2018/04/15/【设计模式】面向对象六大原则/","text":"设计模式设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化。设计模式分为三种类型，分别是：创建型模式、结构型模式，行为型模式。 23种设计模式 创建型模式，共5种：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 六大原则1，单一职责原则（Single Responsibility Principle, SRP）定义：一个类应只包含单一的职责。 如果一个类职责过多，代码量就多，而使用起来显得过分冗余，不利于复用。 如果修改某个职责，可能影响另一个职责。 2，开放封闭原则(Open - ClosedPrinciple ,OCP)定义：一个模块、类、函数应当是对修改关闭，对扩展开放。 修改原有的代码可能会导致原本正常的功能出现问题。 当需求改变时，最好通过扩展来实现，增加新的方法或类满足需求，而不是去修改原有代码。 3，里氏代换原则( Liskov Substitution Principle ,LSP )定义：使用父类的地方能够使用子类来替换，反过来，则不行。 使用子类对象去替换父类对象，程序将不会产生错误。 程序中尽量使用基类类型来对对象进行定义，如父类的子类引用，而在运行时再确定其子类类型，用子类对象来替换父类对象。 4，依赖倒转原则( Dependence Inversion Principle ,DIP )定义：抽象不应该依赖于细节，细节应当依赖于抽象。 即要面向接口编程，而不是面向具体实现去编程。 高层模块不应该依赖低层模块，应该去依赖抽象。 方法定义时，传入对象用抽象类型，实际使用时传入子类对象。 5，接口隔离法则(Interface Segregation Principle，ISL）定义：一个类对另一个类的依赖应该建立在最小的接口上。 一个类不应该依赖他不需要的接口，接口的方法全要用得到。 接口粒度要尽可能小，尽量不能再分割。一个接口的方法过多，可以拆成多个接口。 6，迪米特法则(Law of Demeter, LoD)定义：一个类尽量不要与其他类发生关系 一个类对其他类知道的越少越好，耦合越小。导入的东西越少越好。 当修改一个类时，其他类的影响就越小，发生错误的可能性就越小。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wzmyyj.top/tags/设计模式/"}]}]