[{"title":"IM中群消息发送者信息刷新方案","date":"2020-07-21T11:20:30.000Z","path":"2020/07/21/android_10/","text":"前言在IM项目（Android）中，聊天页面，进入会展示历史消息，而历史消息存下来的发送者信息可能并不是最新的，所以需要去刷新数据。单聊场景只需要刷新对方一个人信息，实现较为简单。但是到群聊，发送者众多，不可能每次进入页面都去获取全部成员的信息（数量大，获取缓慢），所以需要制定策略去实现好的效果。 需求分析期望： 只去刷新显示在屏幕上的发送者信息。 每个发送者只需要刷新一次。（做个缓存） 屏幕滚动很快，中途显示的不去刷新。 如果其他地方缓存过了这个成员，就不再去获取。 群成员信息修改，及时刷新缓存数据。 方案设计设计： 在recycler的onBindVH里收集消息列表里的发送者的ID（imAccount)。 收集到数据池（只收集不是最新数据的，防止反复收集），对imAccount去重，大小为10。利用LRU的缓存淘汰imAccount。 静置0.5秒后开始将缓存池内容发射请求。（即屏幕停止了滑动，或滑动没时新的item添加到屏幕）。 每个imAccount对应一个锁对象，保证异步下同一个imAccount只会请求一次。 结合群成员信息做缓存。（群成员缓存获取过了，如进过群成员页等， 就不再去请求，直接使用缓存里的数据） 刷新成功一个imAccount则会把整个列表里同一个发送者的信息都刷新掉。 数据刷新成功，回调刷新UI列表。需要绑定聊天页面生命周期。 收到群成员信息修改通知消息，修改缓存数据。 流程图： 代码实现该部分功能需要结合成员缓存功能。请看：IM项目中群成员获取与缓存策略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228class SenderHelper private constructor() : DefaultLifecycleObserver &#123; companion object &#123; private const val CACHE_MAX_SIZE = 10 private const val COUNT_DOWN_DELAY = 500L // 保证一对一的关系。 private val map = WeakHashMap&lt;LifecycleOwner, SenderHelper&gt;() fun with(owner: LifecycleOwner, observer: Observer&lt;List&lt;String&gt;&gt;): SenderHelper &#123; return map[owner] ?: SenderHelper().apply &#123; map[owner] = this with(owner, observer) &#125; &#125; fun get(owner: LifecycleOwner): SenderHelper? &#123; return map[owner] &#125; fun get(sessionId: String): SenderHelper? &#123; return map.values.find &#123; it.sessionId == sessionId &#125; &#125; &#125; // 回调的 liveData。 private val liveData = MutableLiveData&lt;List&lt;String&gt;&gt;() // rx。 private var compositeDisposable = CompositeDisposable() // 入参缓存池。 private val cache = LruCache&lt;String, Unit&gt;(CACHE_MAX_SIZE) // 结果列表。 private val resultList = CopyOnWriteArrayList&lt;String&gt;() // 锁对象 map。 private val lockMap = ConcurrentHashMap&lt;String, Lock&gt;() // data。 private var groupCode: String = \"\" private var sessionId: String = \"\" private lateinit var dataList: (Unit) -&gt; List&lt;SenderModel&gt; private val memberSet by lazy &#123; MemberHelper.getIfAbsent(groupCode) &#125; private val handler = Handler() private val runnable = Runnable &#123; cache.snapshot().keys.apply &#123; forEach &#123; k -&gt; cache.remove(k) &#125; task(this.toList()) &#125; &#125; /** * 初始化。 */ fun init(sessionId: String, groupCode: String, dataList: (Unit) -&gt; List&lt;SenderModel&gt;) &#123; this.sessionId = sessionId this.groupCode = groupCode this.dataList = dataList &#125; /** * 获取最新数据。 */ fun bind(sender: SenderModel) &#123; // 如果是自己，直接返回。 if (sender.isSelf || sender.imAccount.isEmpty()) return // 如果最新，直接返回。 memberSet.get(sender.imAccount)?.let &#123; if (compare(sender, it).falseRun &#123; changeListAndPost(it) &#125;) return &#125; // 存入缓存池。 cache.get(sender.imAccount) ?: cache.put(sender.imAccount, Unit) countDown() &#125; /** * 主动刷新名称。 */ fun updateNickname(imAccount: String, nickname: String) &#123; memberSet.get(imAccount)?.let &#123; it.nickName = nickname changeListAndPost(it) &#125; &#125; /** * 主动刷新身份。 */ fun updateGroupRole(imAccount: String, groupRole: Int) &#123; memberSet.get(imAccount)?.let &#123; it.groupRole = groupRole changeListAndPost(it) &#125; &#125; override fun onDestroy(owner: LifecycleOwner) &#123; compositeDisposable.clear() handler.removeCallbacksAndMessages(null) map.remove(owner) &#125; //---------private method-----------// /** * 绑定生命周期和观察。 */ private fun with(owner: LifecycleOwner, observer: Observer&lt;List&lt;String&gt;&gt;) &#123; owner.lifecycle.addObserver(this) liveData.observe(owner, observer) &#125; /** * 延时计时。 */ private fun countDown() &#123; handler.removeCallbacksAndMessages(null) handler.postDelayed(runnable, COUNT_DOWN_DELAY) &#125; /** * 任务。 */ private fun task(imAccountList: List&lt;String&gt;) &#123; Observable .fromIterable(imAccountList) .flatMap &#123; work(it) &#125; .doFinally &#123; if (resultList.isNotEmpty()) &#123; liveData.postValue(ArrayList(resultList)) resultList.clear() &#125; &#125; .subscribe(&#123;&#125;, &#123;&#125;) .addToComposite() &#125; /** * 工作。各自开辟子线程。 */ private fun work(imAccount: String): Observable&lt;*&gt; &#123; return Observable.just(imAccount) .subscribeOn(Schedulers.io()) .flatMap &#123; synchronized(getLock(it).lock) &#123; if (memberSet.get(it) == null) &#123; netWork(it) &#125; else &#123; Observable.just(it) &#125; &#125; &#125; &#125; /** * 网络操作。与工作同一个线程。 */ private fun netWork(imAccount: String): Observable&lt;*&gt; &#123; return MemberHelper .loadMember(sessionId, imAccount) .filter &#123; it.status &amp;&amp; it.entry != null &#125; .map &#123; it.entry!! &#125; .doOnNext &#123; resultList.add(it.imAccount.orEmpty()) memberSet.put(it) updateDb(it) changeList(it) &#125; &#125; /** * * 更新数据库数据。 */ private fun updateDb(bean: MemberBean) &#123; ...修改数据库实现不重要... &#125; /** * 刷洗数据及发送数据变化信号。 */ private fun changeListAndPost(bean: MemberBean) &#123; changeList(bean).trueRun &#123; liveData.postValue(arrayListOf(bean.imAccount.orEmpty())) &#125; &#125; /** * 刷新列表数据。 */ private fun changeList(bean: MemberBean): Boolean &#123; val isChange: Boolean dataList() .filter &#123; it.imAccount == bean.imAccount &amp;&amp; compare(it, bean).not() &#125; .apply &#123; isChange = this.isNotEmpty() &#125; .forEach &#123; it.nickName = bean.nickName.orEmpty() it.avatar = bean.avatar?.toLoadUrl().orEmpty() it.setGroupRole(bean.groupRole) &#125; return isChange &#125; /** * 比较是否最新了。 */ private fun compare(sender: SenderModel, bean: MemberBean): Boolean &#123; return (bean.groupRole == sender.groupRole &amp;&amp; bean.nickName == sender.nickName &amp;&amp; bean.avatar?.toLoadUrl() == sender.avatar) &#125; /** * 锁。 */ class Lock(val lock: Any = Any()) /** * 获取锁对象。 */ private fun getLock(imAccount: String): Lock &#123; return lockMap[imAccount] ?: Lock().apply &#123; lockMap[imAccount] = this &#125; &#125; /** * add 到复合体。 */ private fun Disposable.addToComposite() &#123; compositeDisposable.add(this) &#125;&#125; 使用： 初始化：123SenderHelper .with(lifecyclerOwner, Observer &#123; updateList() &#125;) .init(sessionId, groupCode) &#123; getSenderList() &#125; 在recyclerView适配器的onBindVH处：1SenderHelper.get(lifecyclerOwner)?.bind(sender) 收到消息主动刷新缓存：1234// 更新名称。SenderHelper.get(sessionId)?.updateNickname(imAccount,nickName）// 更新身份。SenderHelper.get(sessionId)?.updateGroupRole(imAccount,groupRole） 总结要点： 收集最新进入的 imAccount，最多10个。 静置 0.5 秒，将收集的数据分别请求。 同一个 imAccount 只能请求一次。 绑定生命周期，一对一关系。 与群成员缓存结合。 PS：从这个方案中，可以扩展到列表内容局部数据请求接口刷新的场景。","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"IM中按名称拼音字母分组排序","date":"2020-07-21T02:20:30.000Z","path":"2020/07/21/android_9/","text":"前言：在IM项目（Android项目）中，例如群成员列表，通讯录（仿微信）等等。往往会按名称首字母分组并排序。从而方便用户检索。 需求：先上一张UI效果图： 分析需求 每个item需要按首字母分组，群主和管理员单独一组。A～Z以外的字符放入‘#’这组。 每组内按文字拼音排序。 每组之间有分隔标题。 右侧 SideBar （自定义View）快速检索。 注：SideBar自定义View并非本文重点。当作有这个View就是了，文末会给代码，自己去实现更好哈😊。 方案设计按字母分组：针对需求1，2。写一个通用的类去做这个时。（尽量与具体业务解耦，也方便日后总结。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162object LatterSetUtil &#123; // \"★\" 代表特殊分类。 private val LETTERS = arrayOf(\"★\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"#\") /** * 容器。 */ class Container&lt;T : ILetter&gt; &#123; internal val map: HashMap&lt;String, ArrayList&lt;T&gt;&gt; = HashMap() init &#123; // 建立字母分组map。 for (s in LETTERS) &#123; map[s] = ArrayList() &#125; &#125; /** * 排序后的列表。 */ fun getSortList(sort: (ArrayList&lt;T&gt;) -&gt; Unit, addLetter: Boolean = true): List&lt;Any&gt; &#123; val resultList = ArrayList&lt;Any&gt;() // 将分组结果排成列表。 for (s in LETTERS) &#123; val list = map[s] // 集合非空才能加入。 if (list.isNullOrEmpty()) continue if (addLetter) &#123; resultList.add(Letter(s, list.size)) &#125; sort(list) resultList.addAll(list) &#125; return resultList &#125; &#125; class Letter(val letter: String, val size: Int) interface ILetter &#123; /** * 获取首字母。 */ fun getFirstLetter(): String = \"#\" &#125; /** * 按字母分组。 * * @param dataList 数据源。 */ fun &lt;T : ILetter&gt; getContainer(dataList: List&lt;T&gt;): Container&lt;T&gt; &#123; val c = Container&lt;T&gt;() // 默认放入\"#\"集合。 val defList = c.map[\"#\"] ?: return c // 将原数据分组。 for (ifl in dataList) &#123; // 获取首字母。 val s = ifl.getFirstLetter() val list = c.map[s] ?: defList // 加入对应字母的小组。 list.add(ifl) &#125; return c &#125;&#125; 使用： 数据源需要实现LatterSetUtil.ILetter接口。 放入数据源（list）返回一个容器对象。里面是已经按字母分好组的集合。 调用getSortList方法，返回一个list。外部指定组内排序规则，每组之前会插一个Letter记录首字母和这组元素的数量。 获取首字母 根据中文获取首字母，原先，自己写了个根据汉字编码规律，按字符区间去判断首字母的方法。能覆盖大多场景，但是很快就被测试找出了反例😓。于是采用现有的“汉语拼音”库：pinyin4j。1implementation 'com.belerweb:pinyin4j:2.5.1' 代码： 1234567891011121314151617181920212223242526272829303132public class FirstLetterUtil &#123; // 根据一个包含汉字的字符串返回一个汉字拼音首字母的字符串 最重要的一个方法. @NonNull public static String first(@Nullable String str) &#123; if (str == null || str.equals(\"\")) &#123; return \"#\"; &#125; char ch = str.charAt(0); if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; return (char) (ch - 'a' + 'A') + \"\"; &#125; if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; return ch + \"\"; &#125; try &#123; HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat(); // 设置大小写格式 defaultFormat.setCaseType(HanyuPinyinCaseType.UPPERCASE); // 设置声调格式： defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE); if (Character.toString(ch).matches(\"[\\\\u4E00-\\\\u9FA5]+\")) &#123; String[] array = PinyinHelper.toHanyuPinyinStringArray(ch, defaultFormat); if (array != null) &#123; return array[0].charAt(0) + \"\"; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"#\"; &#125;&#125; PS：HanyuPinyin：汉语拼音。。。。汗😓。。 使用： 让MemberVhModel实现LatterSetUtil.ILetter接口，getFirstLetter()实现为返回this.latter。latter属性在设置名称时赋值（利用FirstLetterUtil）。 注：不直接在getFirstLetter()方法返回FirstLetterUtil.first(name)。是因为FirstLetterUtil的这个方法效率并不是很高，而getFirstLetter()调用可能较为频繁。其次，MemberVhModel尽量写数据，业务逻辑最好解耦。 组合列表将上述内容组合起来。123456789101112131415161718192021/** * 列表变化。 */ private fun sortMemberAndLetterList(dataList: List&lt;MemberVhModel&gt;, memberSet: MemberSetModel) &#123; memberSet.clearMembers() val container = LatterSetUtil.getContainer(dataList) val lsList = container.getSortList(&#123; sortMemberList(it) &#125;) for (ls in lsList) &#123; if (ls is LatterSetUtil.Letter) &#123; val model = MemberTitleVhModel(title = ls.letter, letter = ls.letter, size = ls.size) if (ls.letter == ADMIN_LETTER) &#123;// 管理员。 model.title = String.format(getString(R.string.im_group_admin_count), ls.size) &#125; memberSet.letterList.add(ls.letter) memberSet.itemList.add(model) &#125; else if (ls is MemberVhModel) &#123; memberSet.itemList.add(ls) memberSet.userList.add(ls) &#125; &#125; &#125; 组内排序： 1234567private val cmp = Collator.getInstance(Locale.CHINA)!! /** * 排序。 */ fun sortMemberList(list: ArrayList&lt;MemberVhModel&gt;) &#123; list.sortWith(Comparator &#123; l, r -&gt;cmp.compare(l.name, r.name)&#125;) &#125; UI方案xml布局：把这个布局include到具体的大页面中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/color_EEEEEE\"&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=\"@+id/rv_member\" binding_rv_data=\"@&#123;item.syncList&#125;\" binding_rv_noAnim=\"@&#123;true&#125;\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/color_EEEEEE\" android:orientation=\"vertical\" android:scrollbars=\"none\" app:layoutManager=\"androidx.recyclerview.widget.LinearLayoutManager\"&gt; &lt;/androidx.recyclerview.widget.RecyclerView&gt; &lt;--这是吸顶的title。--&gt; &lt;TextView android:id=\"@+id/tv_title\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/pt_36\" android:background=\"@color/white\" android:gravity=\"center_vertical\" android:paddingStart=\"@dimen/pt_15\" android:paddingEnd=\"@dimen/pt_15\" android:textColor=\"@color/color_3CC55D\" android:textSize=\"@dimen/pt_17\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" tools:text=\"A\" /&gt; &lt;自定义的.SideBar android:id=\"@+id/sb_letter\" android:layout_width=\"@dimen/pt_40\" android:layout_height=\"match_parent\" android:layout_marginTop=\"@dimen/pt_20\" android:layout_marginBottom=\"@dimen/pt_30\" android:focusable=\"true\" android:paddingStart=\"@dimen/pt_20\" android:paddingEnd=\"10dp\" android:textColorHighlight=\"@color/color_3CC55D\" android:textSize=\"@dimen/pt_12_5\" app:layout_constraintEnd_toEndOf=\"parent\" /&gt; &lt;--这是按住SideBar展示的字母。--&gt; &lt;TextView android:id=\"@+id/tv_letter\" android:layout_width=\"@dimen/pt_54\" android:layout_height=\"@dimen/pt_45\" android:layout_marginEnd=\"@dimen/pt_40\" android:background=\"@drawable/im_bg_side_bar_txt\" android:gravity=\"center\" android:includeFontPadding=\"false\" android:paddingStart=\"@dimen/pt_1\" android:paddingEnd=\"@dimen/pt_10\" android:textColor=\"@color/color_3CC55D\" android:textSize=\"@dimen/pt_20\" android:visibility=\"gone\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toTopOf=\"@id/sb_letter\" tools:text=\"★\" tools:visibility=\"visible\" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; RecyclerView与SideBar有联动效果。并且与具体数据业务无关。所以把这部分代码解耦出来。不单成员列表一个页面用。添加，删除群成员，AT成员页面都有一样的逻辑。要学会抽离公共逻辑👌。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950object MemberListUI &#123; // 数据记录。 private class Data(var lastPosition: Int = -1) fun init(binding: ImCommonMemberListBinding, rvAdapter: RecyclerView.Adapter&lt;*&gt;) &#123; val data = Data() // 这是RecyclerView。 binding.rvMember.run &#123; adapter = rvAdapter addOnScrollListener(object : RecyclerView.OnScrollListener() &#123; override fun onScrolled(v: RecyclerView, dx: Int, dy: Int) &#123; super.onScrolled(v, dx, dy) val item = binding.item ?: return val headerCount = MemberUtil.getHeaderCount(item) // v.getChildAt(0)不会越界异常，超出索引会返回null。 val position = v.getChildAt(0)?.let &#123; v.getChildLayoutPosition(it) &#125; ?: 0 // 吸顶效果。 binding.tvTitle.setVisible(position &gt; headerCount) // position发生变化时。 if (data.lastPosition != position) &#123; binding.tvTitle.text = MemberUtil.getTitleByIndex(item, position - headerCount) data.lastPosition = position &#125; &#125; &#125;) &#125; // 这是SlideBar。 binding.sbLetter.run &#123; setTextView(binding.tvLetter) setOnTouchingLetterChangedListener &#123; letter -&gt; // 联动成员列表。 val item = binding.item ?: return@setOnTouchingLetterChangedListener val index = MemberUtil.getIndexByLetter(item, letter) if (index &lt; 0) return@setOnTouchingLetterChangedListener // 列表前可能有header。 val headerCount = MemberUtil.getHeaderCount(item) val position = index + headerCount if (position in 0 until rvAdapter.itemCount) &#123; val layoutManager = binding.rvMember.layoutManager if (layoutManager is LinearLayoutManager) &#123; layoutManager.scrollToPositionWithOffset(position, 0) &#125; if (data.lastPosition != position) &#123; binding.tvTitle.text = MemberUtil.getTitleByIndex(item, position - headerCount) data.lastPosition = position &#125; &#125; &#125; &#125; &#125;&#125; 使用： 只需要一句话。写在View的初始化处。（vList是include的布局ID转过来的binding。）1MemberListUI.init(binding.vList, memberAdapter) 总结这篇的借着群成员列表的业务，主要想讲述一下几点。 要点： 数据结构相关，尽量从业务中抽离。达到可复用效果。 数据类尽量不写具体逻辑。除了实现接口，尽可能简单。复杂逻辑外面去做。 公共UI试着抽离业务。 体会： 把代码实现有条理一点，总结起来愉快一些😊。 附件SideBar.java","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"IM项目中群成员获取与缓存策略","date":"2020-07-21T02:00:30.000Z","path":"2020/07/21/android_8/","text":"前言在IM项目（Android）中，我们需要获取群成员，往往数据较大，获取缓慢，所以需要做个缓存，提升用户体验。 策略 如果本地（缓存里）有完整数据，则取缓存里数据，否则从网路获取。（可能多个地方需要加载成员列表，但无法保证那处先加载。比如查看群成员，选择AT群内某人，管理员列表等等。） 从网络获取全部成员时，分页获取。采用递归请求，直到没有下一页。 最多缓存15个群的成员，如果超过15个，淘汰掉最近最少使用的那个群的成员。 单个成员信息获取，会存在临时成员里。（用途是，在群聊天页，实时刷新调天发送者信息。）如果这个群已经有完成的群成员列表，则删除临时成员。（聊天页发送者信息直接从完整的群成员表里取出对比）。 支持修改缓存数据。包括增加，删除，修改成员。 方案设计缓存：定义成员集合接口：1234567891011121314151617181920212223242526272829/** * 成员集合接口。 */interface IMemberSet &#123; /** * 放入单个成员。 */ fun put(member: MemberBean) /** * 获取成员。 */ fun get(imAccount: String): MemberBean? /** * 放入全部成员。 */ fun putAll(memberList: ArrayList&lt;MemberBean&gt;) /** * 获取全部成员。 */ fun getAll(): ArrayList&lt;MemberBean&gt; /** * 大小。 */ fun size(): Int /** * 是否全部。 */ fun isAll(): Boolean&#125; 定义缓存器接口：123456789/** * 缓存器接口。可自定义缓存策略。 */private interface IMemberCache &#123; fun put(groupCode: String, memberSet: IMemberSet) fun get(groupCode: String): IMemberSet? fun remove(groupCode: String) fun clear()&#125; 获取：先判断缓存，再递归获取全部群成员。12345678910111213141516171819202122232425262728293031323334353637383940414243private val repository by lazy &#123; MemberRepository(RetrofitHelper.instance.createApiService(MemberApi::class.java))&#125;/** * 加载群成员。 * @param groupCode 群号。 * @param justByNet 只通过网络获取。会把结果缓存。 */fun loadMemberList(groupCode: String, justByNet: Boolean = false): Observable&lt;ArrayList&lt;MemberBean&gt;&gt; &#123; val cacheSet = cache.get(groupCode) return if (cacheSet != null &amp;&amp; cacheSet.isAll() &amp;&amp; justByNet.not()) &#123; // 从缓存中获取。 Observable.just(cacheSet.getAll()) &#125; else &#123; // 从网络获取。 val list = ArrayList&lt;MemberBean&gt;() getMemberListFromNet(groupCode, 1, list) .doOnNext &#123; val set = cacheSet ?: MemberSet() set.putAll(it) cache.put(groupCode, set) &#125; &#125;&#125;//---------private method-----------///** * 递归获取群成员。 */private fun getMemberListFromNet(groupCode: String, pageNo: Int, beanList: ArrayList&lt;MemberBean&gt;) : Observable&lt;ArrayList&lt;MemberBean&gt;&gt; &#123; return repository .postGroupMembers(groupCode, pageNo, pageSize) .filter &#123; it.status.falseRun &#123; throw RuntimeException(it.message.orEmpty()) &#125; &#125; .flatMap &#123; it.entry?.groupMemberList?.let &#123; l -&gt; beanList.addAll(l) &#125; return@flatMap if (it.entry?.hasNextPage == true) &#123; getMemberListFromNet(groupCode, pageNo + 1, beanList) &#125; else &#123; Observable.just(beanList) &#125; &#125;&#125; 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176object MemberHelper &#123; private const val pageSize: Int = 500 // 缓存15个群。 private const val maxCount: Int = 15 /** * 缓存器接口。可自定义缓存策略。 */ private interface IMemberCache &#123; fun put(groupCode: String, memberSet: IMemberSet) fun get(groupCode: String): IMemberSet? fun remove(groupCode: String) fun clear() &#125; /** * 成员集合接口。 */ interface IMemberSet &#123; /** * 放入单个成员。 */ fun put(member: MemberBean) /** * 获取成员。 */ fun get(imAccount: String): MemberBean? /** * 放入全部成员。 */ fun putAll(memberList: ArrayList&lt;MemberBean&gt;) /** * 获取全部成员。 */ fun getAll(): ArrayList&lt;MemberBean&gt; /** * 大小。 */ fun size(): Int /** * 是否全部。 */ fun isAll(): Boolean &#125; /** * 默认用 LRU 缓存。 */ private val cache: IMemberCache = LruMemberCache(maxCount) private val repository by lazy &#123; MemberRepository(RetrofitHelper.instance.createApiService(MemberApi::class.java)) &#125; /** * 移除一个群成员的缓存。 */ fun remove(groupCode: String) &#123; cache.remove(groupCode) &#125; /** * 获取缓存里的集合。 */ fun get(groupCode: String): IMemberSet? &#123; return cache.get(groupCode) &#125; /** * 获取 IMemberSet 如果没有，就存一个进去。 */ fun getIfAbsent(groupCode: String): IMemberSet &#123; return cache.get(groupCode) ?: MemberSet().apply &#123; cache.put(groupCode, this) &#125; &#125; /** * 清空。 */ fun clear() &#123; cache.clear() &#125; /** * 加载单个成员在这个群的信息。 * @param sessionId 会话。 * @param imAccount IM号。 */ fun loadMember(sessionId: String, imAccount: String): Observable&lt;HttpResponse&lt;MemberBean&gt;&gt; &#123; return repository.getUserInfoBySession(sessionId, imAccount) &#125; /** * 加载群成员。 * @param groupCode 群号。 * @param justByNet 只通过网络获取。会把结果缓存。 */ fun loadMemberList(groupCode: String, justByNet: Boolean = false): Observable&lt;ArrayList&lt;MemberBean&gt;&gt; &#123; val cacheSet = cache.get(groupCode) return if (cacheSet != null &amp;&amp; cacheSet.isAll() &amp;&amp; justByNet.not()) &#123; // 从缓存中获取。 Observable.just(cacheSet.getAll()) &#125; else &#123; // 从网络获取。 val list = ArrayList&lt;MemberBean&gt;() getMemberListFromNet(groupCode, 1, list) .doOnNext &#123; val set = cacheSet ?: MemberSet() set.putAll(it) cache.put(groupCode, set) &#125; &#125; &#125; //---------private method-----------// /** * 递归获取群成员。 */ private fun getMemberListFromNet(groupCode: String, pageNo: Int, beanList: ArrayList&lt;MemberBean&gt;) : Observable&lt;ArrayList&lt;MemberBean&gt;&gt; &#123; return repository .postGroupMembers(groupCode, pageNo, pageSize) .filter &#123; it.status.falseRun &#123; throw RuntimeException(it.message.orEmpty()) &#125; &#125; .flatMap &#123; it.entry?.groupMemberList?.let &#123; l -&gt; beanList.addAll(l) &#125; return@flatMap if (it.entry?.hasNextPage == true) &#123; getMemberListFromNet(groupCode, pageNo + 1, beanList) &#125; else &#123; Observable.just(beanList) &#125; &#125; &#125; /** * LRU缓存器。 */ private class LruMemberCache(maxSize: Int) : IMemberCache &#123; private val lruCache = LruCache&lt;String, IMemberSet&gt;(maxSize) override fun put(groupCode: String, memberSet: IMemberSet) &#123; lruCache.put(groupCode, memberSet) &#125; override fun get(groupCode: String): IMemberSet? &#123; return lruCache.get(groupCode) &#125; override fun remove(groupCode: String) &#123; lruCache.remove(groupCode) &#125; override fun clear() &#123; lruCache.evictAll() &#125; &#125; /** * 成员集合。 */ private class MemberSet : IMemberSet &#123; // 全部成员列表。 private val list = ArrayList&lt;MemberBean&gt;() // 是否全部成员。 private var all: Boolean = false // 临时存放的成员。信息不全的bean。 private val map = HashMap&lt;String, MemberBean&gt;() override fun putAll(memberList: ArrayList&lt;MemberBean&gt;) &#123; list.clear() list.addAll(memberList) all = true map.clear() &#125; override fun getAll(): ArrayList&lt;MemberBean&gt; = list override fun size(): Int = list.size + map.size override fun isAll(): Boolean = all override fun put(member: MemberBean) &#123; val have = all &amp;&amp; list.find &#123; it.imAccount == member.imAccount &#125;?.apply &#123; nickName = member.nickName groupRole = member.groupRole avatar = member.avatar &#125; != null if (!have) &#123; map[member.imAccount.orEmpty()] = member &#125; &#125; override fun get(imAccount: String): MemberBean? &#123; return list.find &#123; it.imAccount == imAccount &#125; ?: map[imAccount] &#125; &#125;&#125; 注：lruCache 计算size，不能用成员个数（即list.size()）来计算，因为一个群的成员在存入后中途是大小会发生变化，会导致lruCache内部维护的size计算小于0 ，trimToSize 方法 抛出IllegalStateException 异常。1234if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + \".sizeOf() is reporting inconsistent results!\"); &#125; 使用 获取数据：loadMemberList()。可以指定强制从网络获取。 群成员新增时，一般是清空这个群的缓存数据。让下次重新获取，因为新增群成员时，并不能拿到这个成员在这个群的详情。 删除和修改直接修改缓存里的数据。 结合聊天页面单个消息发送者去刷新数据。（这个下一篇会讲）。 总结 设计好一个数据结构，能使开发实现更有条理。 lruCache，计算size，对同一个元素，size应当不可变。","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"小故事：未熟的果实","date":"2020-07-20T01:50:00.000Z","path":"2020/07/20/story_2/","text":"故事某个场景。 天后要带她回天界，她不愿意发生了争执。我正躲在墙后清楚地听着一切。到后面，她不想再说什么任性地跑了。我主动走了出来，面见天后，说了些“每个人可以追求自由”的话。天后先不追究，暂时放手。 我知道，并不是我的话打动天后，而是天后爱自己的女儿，凡人的理念在她看来只是一些幼稚的儿话。 我来到一个仓库间，我知道她一定藏在这休息。我把一张纸片对折放在桌子上的剪刀旁边。我找到了她，她正裹着麻袋小睡。她半睁开眼乏力地对我说，她需要离开这里。 我背着她走在山间的马路上，两边茂盛的树丛里开着杜鹃花。她下巴搭在我左肩上，侧脸偶偶触碰到我的耳根。 我问她：“为什么给我和某些人一张纸？” 她直率回答道：“为了比较。” 我内心叹了口气，点了点头。说道：“也是，人活着就是竞争，有竞争就有比较。” 不久，我们到了目的地，一所大别墅。她下来我扶着她走。她要走长满花的小道。我在地上捡起一颗松果大小的果实。她问这是什么？我说这是一种无名树的果子，成熟后是能够吃的。我打开果实，里面的果肉还是透明里带青，显然果实还没有成熟。","tags":[{"name":"故事","slug":"故事","permalink":"https://wzmyyj.top/tags/故事/"}]},{"title":"IM项目中的自定义小表情实现","date":"2020-07-19T02:10:30.000Z","path":"2020/07/19/android_7/","text":"前言在im项目（Android）中，用户发消息，喜欢在文字中嵌入一些小表情，以表达发送者当时的情感。除了系统输入法自带的emoji表情（emoji其实是特殊的文字）外。项目希望带一些更漂亮，带产品特色文化的自定义小表情（小图片）。 图片嵌入在文字中显示，很明显可以使用ImageSpan去实现该效果。 效果如图： 实现：实现上，主要问题是，实现文字与表情的转换。因此需要定义一套对应关系。 这里采用类似微信的实现，[key]对应表情。比如： [微笑] 对应 😊。 工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154object EmoticonHelper &#123; private const val SIGN_LEFT = '[' private const val SIGN_RIGHT = ']' private const val ZOOM_SIZE = 1.3F private const val CACHE_SIZE = 60 private val def = R.drawable.im_emoticon_def private val keyList = ArrayList&lt;String&gt;() private val cache = LruCache&lt;String, Drawable&gt;(CACHE_SIZE) // 表情。 private val map = hashMapOf( \"微笑\" kto R.drawable.im_emoticon_wx, \"撇嘴\" kto R.drawable.im_emoticon_pz, \"色\" kto R.drawable.im_emoticon_se, \"得意\" kto R.drawable.im_emoticon_dy, \"大哭\" kto R.drawable.im_emoticon_dk, \"发呆\" kto R.drawable.im_emoticon_fd, \"闭嘴\" kto R.drawable.im_emoticon_bz, \"睡\" kto R.drawable.im_emoticon_shui, \"流泪\" kto R.drawable.im_emoticon_ll, \"尴尬\" kto R.drawable.im_emoticon_gg, \"发怒\" kto R.drawable.im_emoticon_fn, \"调皮\" kto R.drawable.im_emoticon_tb, \"惊讶\" kto R.drawable.im_emoticon_jy, \"囧\" kto R.drawable.im_emoticon_jiong, \"吐\" kto R.drawable.im_emoticon_tu, \"哇\" kto R.drawable.im_emoticon_wa, \"偷笑\" kto R.drawable.im_emoticon_tx, \"愉快\" kto R.drawable.im_emoticon_yk, \"白眼\" kto R.drawable.im_emoticon_by, \"恐惧\" kto R.drawable.im_emoticon_kj, \"衰\" kto R.drawable.im_emoticon_shuai, \"笑哭\" kto R.drawable.im_emoticon_kx, \"无语\" kto R.drawable.im_emoticon_ww, \"晕\" kto R.drawable.im_emoticon_yun, \"困\" kto R.drawable.im_emoticon_kun, \"亲亲\" kto R.drawable.im_emoticon_qq, \"庆祝\" kto R.drawable.im_emoticon_qz, \"汗\" kto R.drawable.im_emoticon_han, \"咒骂\" kto R.drawable.im_emoticon_zm, \"嘘\" kto R.drawable.im_emoticon_xu, \"可怜\" kto R.drawable.im_emoticon_kl, \"失望\" kto R.drawable.im_emoticon_sw, \"憨笑\" kto R.drawable.im_emoticon_hx, \"呲牙\" kto R.drawable.im_emoticon_cy, \"拥抱\" kto R.drawable.im_emoticon_yb, \"思考\" kto R.drawable.im_emoticon_sk, \"口罩\" kto R.drawable.im_emoticon_kz, \"悠闲\" kto R.drawable.im_emoticon_yxi, \"委屈\" kto R.drawable.im_emoticon_wq, \"吐舌头\" kto R.drawable.im_emoticon_tst, \"鬼脸\" kto R.drawable.im_emoticon_gl, \"阴险\" kto R.drawable.im_emoticon_yx, \"啤酒\" kto R.drawable.im_emoticon_pj, \"玫瑰\" kto R.drawable.im_emoticon_mg, \"凋谢\" kto R.drawable.im_emoticon_dx, \"太阳\" kto R.drawable.im_emoticon_ty, \"火\" kto R.drawable.im_emoticon_huo, \"礼物\" kto R.drawable.im_emoticon_lw, \"爱心\" kto R.drawable.im_emoticon_ax, \"心碎\" kto R.drawable.im_emoticon_xs, \"强\" kto R.drawable.im_emoticon_qiang, \"弱\" kto R.drawable.im_emoticon_ruo, \"鼓掌\" kto R.drawable.im_emoticon_gz, \"OK\" kto R.drawable.im_emoticon_ok, \"蛋糕\" kto R.drawable.im_emoticon_dg, \"合十\" kto R.drawable.im_emoticon_h10, \"胜利\" kto R.drawable.im_emoticon_sl, \"握手\" kto R.drawable.im_emoticon_ws, \"红包\" kto R.drawable.im_emoticon_hb, \"钱\" kto R.drawable.im_emoticon_qian ) /** * 转换表情。 */ fun transEmoticon(context: Context, text: CharSequence, size: Float): Spannable &#123; val ss = SpannableString.valueOf(text)!! spanEmoticon(context, ss, 0, ss.length, size) return ss &#125; /** * span 表情。返回最后一个span的末尾位置（不包含）。 */ fun spanEmoticon(context: Context, sp: Spannable, startSp: Int, endSp: Int, size: Float): Int &#123; if (endSp - startSp &lt;= 2) return startSp var last = startSp val wh = size.toZoom() var start = sp.indexOf(SIGN_LEFT, startSp) while (start &gt; -1) &#123; val end = sp.indexOf(SIGN_RIGHT, start) if (end &lt;= start || end &gt;= endSp) break val key = sp.substring(start + 1, end) if (key in map.keys) &#123; val drawable = getDrawable(context, key, wh) ?: continue sp.setSpan(ImageSpan(drawable), start, end + 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE) last = end + 1 &#125; start = sp.indexOf(SIGN_LEFT, start + 1) &#125; return last &#125; /** * 获取表情列表。 */ fun getEmoticonList(): List&lt;Emoticon&gt; &#123; return keyList.map &#123; Emoticon(it, it.toCode(), map[it] ?: def) &#125; &#125; class Emoticon(val key: String, val code: String, @DrawableRes val resId: Int) //---------private method-----------// /** * 获取 Drawable 并根据 key 和 大小 缓存。 */ private fun getDrawable(context: Context, key: String, size: Int): Drawable? &#123; return cache[key + size] ?: ContextCompat.getDrawable(context, map[key] ?: def)?.apply &#123; cache.put(key + size, this) this.setBounds(0, 0, size, size) &#125; &#125; /** * 转换成 code。 */ private fun String.toCode() = SIGN_LEFT + this + SIGN_RIGHT /** * 缩放大小。 */ private fun Float.toZoom() = (this * ZOOM_SIZE).toInt() /** * K-V 对，同时保存 key。 */ private infix fun String.kto(that: Int): Pair&lt;String, Int&gt; &#123; keyList.add(this) return Pair(this, that) &#125;&#125; 主要就是做一个转换功能。同时需要考虑一下性能优化，否则效率低就会卡顿。 PS：这里优化了 查询转换策略 和 Drawable复用策略，供参考。 注：Spannable有关的操作，少用String。使用CharSequence，因为不一定是String。用SpannableString.valueOf(text) 代替new SpannableString(text) 使用：在TextView上使用，也写个BindingAdapter方法。 12345678910111213141516171819202122@BindingAdapter(value = [\"binding_text_emoticon\"], requireAll = true)fun TextView.setEmoticonText(text: CharSequence?) &#123; if (this.text?.toString() != text) &#123; this.text = if (text != null) &#123; EmoticonHelper.transEmoticon(context, text, textSize) &#125; else &#123; \"\" &#125; &#125;&#125;@BindingAdapter(value = [\"binding_text_emoticon\", \"binding_text_emoticon_ellipsize\"], requireAll = true)fun TextView.setEmoticonText(text: CharSequence?, avail: Float) &#123; if (this.text?.toString() != text) &#123; this.text = if (text != null) &#123; val emo = EmoticonHelper.transEmoticon(context, text, textSize) TextUtils.ellipsize(emo, paint, avail, TextUtils.TruncateAt.END) &#125; else &#123; \"\" &#125; &#125;&#125; 注：其中TextUtils.ellipsize(emo, paint, avail, TextUtils.TruncateAt.END) 是为了解决表情在单行textView显示不下时显“…”.的问题。直接默认用TextView的ellipsize属性，对表情（ImageSpan）无效，会截成半个。 输入框：表情要在输入框中显示。根据输入code，自动转换成表情（ImageSpan）。 方案1：给EditView设置监听，在文字变化后将文字做个转换。这样效率超低，输入越多越卡。否决！ 方案2：根据具体变化的文本设置转换。 1234567891011121314151617181920212223242526272829303132editText.addTextChangedListener(object : TextWatcher &#123; override fun afterTextChanged(s: Editable?) &#123; &#125; override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123; &#125; override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123; if (s !is Spannable) return // 输入会能影响到的包含前后几格。 val end = start + count val sl = s.lastIndexOf('[', start) val st = if (sl &gt; -1 &amp;&amp; start &lt;= s.indexOf(']', sl)) &#123; sl &#125; else &#123; start &#125; val er = s.indexOf(']', end) val en = if (er &gt; -1 &amp;&amp; s.lastIndexOf('[', er) in 0 until end) &#123; er + 1 &#125; else &#123; end &#125; val last = EmoticonHelper.spanEmoticon(editText.context, s, st, en, editText.textSize) // 如果输入影响后几格，即连同后几格一起变成表情。将光标置于表情末尾。 if (last &gt; end &amp;&amp; last &lt;= s.length) &#123; Selection.setSelection(s, last) &#125; &#125; &#125;) 注：当前输入的东西（可能是复制过来的多个字符）。可能会影响到前面或后面的几个字符。 例如：原本文本：“[微]” ,在“微”后面输入一个“笑”，实际文本是“[微笑]”满足code。就会自动转变成😊表情。此时，光标在“笑”后面，需要代码控制把光标挪到“]”的后面。才符合实际输入效果。 表情选择框操作： 删除：模拟退格，表情需要整个整个删。1editText.dispatchKeyEvent(KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL)) 插入：将code插入到光标末尾。1editText.run &#123; text.insert(selectionEnd, code) &#125; 其他：转发到微信，有些表情微信里没有对应。转换成emoji代替。 123456789101112131415161718192021222324252627282930// 转发微信需要替换成 emoji 的表情。private val emojiMap = hashMapOf( \"恐惧\" to \"\\uD83D\\uDE31\", \"笑哭\" to \"\\uD83D\\uDE02\", \"无语\" to \"\\uD83D\\uDE12\", \"庆祝\" to \"\\uD83C\\uDF89\", \"失望\" to \"\\uD83D\\uDE14\", \"思考\" to \"\\uD83E\\uDD14\", \"口罩\" to \"\\uD83D\\uDE37\", \"吐舌头\" to \"\\uD83D\\uDE1D\", \"鬼脸\" to \"\\uD83D\\uDC7B\", \"火\" to \"\\uD83D\\uDD25\", \"合十\" to \"\\uD83D\\uDE4F\", \"钱\" to \"\\uD83D\\uDCB0\", \"礼物\" to \"\\uD83C\\uDF81\") /** * 转发微信。不支持的 code 转化为 emoji 。 */fun transCodeToEmoji(text: String): String &#123; var str = text for (key in emojiMap.keys) &#123; val code = key.toCode() if (str.contains(code)) &#123; str = str.replace(code, emojiMap[key].orEmpty()) &#125; &#125; return str&#125; 总结：要点： ImageSpan实现表情的显示。😊 code与Drawable的对应关系。 Drawable性能的考量。 表情在EditText里输入的几个优化点。 微信转发时替换code。","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"TextView识别文本中的超链接并能点击跳转","date":"2020-05-12T02:20:30.000Z","path":"2020/05/12/android_6/","text":"需求：如题所诉。需要识别出文本中的链接，并显示成超链接的UI样式。点击能够跳转打开网页（最好是自己app内部的WebView。） 简单实现：在 xml 里给TextView 设置: 12345&lt;TextView android:autoLink=\"web\" android:linksClickable=\"true\" android:textColorLink=\"@color/color_017EBD\".../&gt; 简单，但是有很大的缺点： 链接下的下划线去不掉。 只能跳转到系统默认的浏览器。 链接后面不佳空格有中文就识别不出来。 虽然它不好。但它是系统自带的功能，可以看看它的实现原理，可以关键地方改写它。 原理：根据所学知识。想必也是ClickableSpan的一种实际使用罢了。可以先看看：ClickableSpan的一点点摸索 。 关键类： URLSpan：ClickableSpan的子类，带URL，下划线去不掉。 LinkMovementMethod：ClickableSpan生效所需，之前讲了。 Linkify：一个识别文字中链接，地址，邮箱之类的工具类。 前面两个看ClickableSpan那篇就理解了。重点看Linkify。 Linkify： Linkify take a piece of text and a regular expression and turns all of the regex matches in the text into clickable links. This is particularly useful for matching things like email addresses, web URLs, etc. and making them actionable. Linkify是一个辅助类，通过RegEx样式匹配，自动地在TextView类（和继承的类）中创建超链接。 它的方法public方法有多个重载方法。只需要了解它的主要功能。 我们可以用它实现超链接的识别。写个工具类。 工具类：我们只需要自定义RegEx就可以实现我们自己的识别超链接规则：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859object HyperLinkHelper &#123; private const val REGEX = \"(((http[s]?|ftp?|file?)://)?[a-zA-Z0-9.\\\\-]+\\\\.([a-zA-Z]&#123;2,4&#125;)(:\\\\d+)?(/[a-zA-Z0-9.\\\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)|(www.[a-zA-Z0-9.\\\\-]+\\\\.([a-zA-Z]&#123;2,4&#125;)(:\\\\d+)?(/[a-zA-Z0-9.\\\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)\" /** * 转换成链接。 */ fun transUrlSpan(text: CharSequence, @ColorInt highColor: Int = -0xa8946b): Spannable &#123; val ss = SpannableString.valueOf(text) Linkify.addLinks(ss, Pattern.compile(REGEX), \"\") val urlSpans = ss.getSpans(0, ss.length, URLSpan::class.java) ?: return ss for (sp in urlSpans) &#123; val start = ss.getSpanStart(sp) val end = ss.getSpanEnd(sp) ss.removeSpan(sp) ss.setSpan(UrlLinkSpan(sp.url.formatUrl(), highColor), start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE) &#125; return ss &#125; /** * 设置点击事件。 */ fun setClickListener(spanned: Spanned, listener: UrlLinkSpan.OnClickListener) &#123; spanned.getSpans(0, spanned.length, UrlLinkSpan::class.java) .forEach &#123; it.listener = listener &#125; &#125; private fun String.formatUrl(): String &#123; return if (indexOf(\"http\") != 0 &amp;&amp; indexOf(\"ftp\") != 0 &amp;&amp; indexOf(\"file\") != 0) &#123; \"http://$this\" &#125; else &#123; this &#125; &#125; // 并把URLSpan替换成样式需要的Span。 class UrlLinkSpan(val url: String, @ColorInt val highColor: Int) : ClickableSpan() &#123; var listener: OnClickListener? = null interface OnClickListener &#123; fun onUrlLinkClick(widget: View, url: String) &#125; override fun onClick(widget: View) &#123; listener?.onUrlLinkClick(widget, url) &#125; override fun updateDrawState(ds: TextPaint) &#123; super.updateDrawState(ds) ds.color = highColor ds.isUnderlineText = false &#125; &#125; &#125; 整一个 BindingAdapter 方法： 12345678910111213@BindingAdapter(value = [\"binding_text_url_link\", \"binding_url_link_listener\"], requireAll = true)fun TextView.setUrlLinkText(text: CharSequence?, listener: HyperLinkHelper.UrlLinkSpan.OnClickListener) &#123; if (this.text?.toString() != text) &#123; this.text = if (text != null) &#123; HyperLinkHelper.transUrlSpan(text, getColor(R.color.color_017EBD)).apply &#123; HyperLinkHelper.setClickListener(this, listener) movementMethod = ClickLinkMovementMethod &#125; &#125; else &#123; \"\" &#125; &#125;&#125; ClickLinkMovementMethod 是为了解决长按的问题。ClickableSpan的一点点摸索那篇文章有讲。 扩展：Linkify还可以定义如下接口： Match Filter：实现acceptMatch方法，来为RegEx样式匹配添加额外的条件。当一个潜在的匹配发现时，acceptMatch被触发，匹配的开始点和结束点（包括被查找的整个文本）以参数的形式传入。 Transform Filter：为格式化文本字符串提供更大的自由度，允许你修改由链接文本自动生成的隐式URI。 有兴趣自己去了解。 总结：要点： 正则识别链接 显示样式自定义，去掉下划线。 点击逻辑自定义，跳转到自己的WebView。 解决长按冲突问题。","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"ClickableSpan的一点点摸索","date":"2020-05-12T01:04:30.000Z","path":"2020/05/12/android_5/","text":"ClickableSpanClickableSpan 用来实现 TextView里的文字局部的高亮和点击事件。 介绍： If an object of this type is attached to the text of a TextView with a movement method of LinkMovementMethod, the affected spans of text can be selected. If selected and clicked, the {@link #onClick} method will* be called. 意思是这东西加到TextView上，并设置LinkMovementMethod，就可以选择或点击并回调onClick方法。源码：12345678910111213141516171819202122232425public abstract class ClickableSpan extends CharacterStyle implements UpdateAppearance &#123; private static int sIdCounter = 0; private int mId = sIdCounter++; /** * Performs the click action associated with this span. */ public abstract void onClick(@NonNull View widget); /** * Makes the text underlined and in the link color. */ @Override public void updateDrawState(@NonNull TextPaint ds) &#123; ds.setColor(ds.linkColor); ds.setUnderlineText(true); &#125; /** * Get the unique ID for this span. * * @return The unique ID. * @hide */ public int getId() &#123; return mId; &#125;&#125; 源码比较简单，就是能改变文字样式的同时有个onClick抽象方法。 遇到问题问题：使用中，我们经常在vm层（vm里或者 vm的辅助逻辑类里）设置数据（比如SpannableString），如果设置的是ClickableSpan。设置样式外，还需要实现onClick方法，即点击事件。然而点击事件往往是UI层的逻辑。一般不允许在vm层写点击事件逻辑。向 vm里传点击事件（往往是内部类会持有fragment），不是很可取。目标：我希望vm层只对数据的设置，UI层设置点击事件。 方案：定义一个可以设置事件，并携带数据的 ClickableSpan。1234567891011121314151617181920212223242526272829class DataClickSpan(@ColorInt val color: Int) : ClickableSpan() &#123; val map = HashMap&lt;String, Any?&gt;() var listener: OnClickListener? = null interface OnClickListener &#123; fun onSpanClick(widget: View, map: HashMap&lt;String, Any?&gt;) &#125; override fun onClick(widget: View) &#123; listener?.onSpanClick(widget, map) &#125; override fun updateDrawState(ds: TextPaint) &#123; //设置颜色 ds.color = color //去掉下划线 ds.isUnderlineText = false &#125;&#125;/** * 设置点击事件。 */fun Spanned.setDataClickListener(listener: DataClickSpan.OnClickListener?) &#123; getSpans(0, this.length - 1, DataClickSpan::class.java) .forEach &#123; it.listener = listener &#125;&#125;再整一个BindingAdapter方法：@BindingAdapter(value = [\"binding_spanned_data\", \"binding_spanned_clickListener\"], requireAll = true)fun TextView.setSpannedClickListenerOfString(data: Spanned?, listener: DataClickSpan.OnClickListener?) &#123; data?.setDataClickListener(listener) movementMethod = ClickLinkMovementMethod// 这个是自定义LinkMovementMethod&#125; 使用：vm 层使用，设置携带数据：123456// 携带 imAccountSpannableString(\"这是可以点击的文字\").apply &#123; setSpan(DataClickSpan(getColor(R.color.color_576B95)) .apply &#123; map[IM_ACCOUNT] = joinGroupMsg.inviteImAccount &#125;, 1, length - 1, Spanned.SPAN_INCLUSIVE_EXCLUSIVE) &#125; UI 层使用，设置事件，比如这个SpannableString是设置再某个item的TextView 上。 让这个Item的 VHModel 的OnItemEventListener继承DataClickSpan.OnClickListener 再布局里设置： 1234&lt;TextView binding_spanned_clickListener=\"@&#123;listener&#125;\" binding_spanned_data=\"@&#123;item.removeDesc&#125;\".../&gt; 在Fragment里实现接口： 123456override fun onSpanClick(widget: View, map: HashMap&lt;String, Any?&gt;) &#123; val imAccount = map[ConvertUtil.IM_ACCOUNT] if (imAccount is String) &#123; RouterManager.goImUser(UserParams(imAccount), \"ChatFragment\") &#125;&#125; 结论：没啥好的，就是曲折去实现分离而已。 vm 还有间接依赖View。vm持有SpannableString，SpannableString持有ClickableSpan，ClickableSpan持有listener，listener持有fragment。emmmm…. ClickableSpan设计就是这样。那就来了解了解它的实现原理吧。 LinkMovementMethod：ClickableSpan源码也看了，显然它不是主要关键。那是谁去调用ClickableSpan的onClick方法，怎么决定调用时机呢？ ClickableSpan文件头介绍中，已供出主谋是LinkMovementMethod（是一个单例）。 点击事件，显然离不开onTach的方法。LinkMovementMethod里正好有，那就决定是它了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Override public boolean onTouchEvent(TextView widget, Spannable buffer, MotionEvent event) &#123; int action = event.getAction(); if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) &#123; int x = (int) event.getX(); int y = (int) event.getY(); x -= widget.getTotalPaddingLeft(); y -= widget.getTotalPaddingTop(); x += widget.getScrollX(); y += widget.getScrollY(); // 找触碰的位置。 Layout layout = widget.getLayout(); // 第几行。 int line = layout.getLineForVertical(y); // 第几个字符。 int off = layout.getOffsetForHorizontal(line, x); // 找出触摸到的文本中的 ClickableSpan。 ClickableSpan[] links = buffer.getSpans(off, off, ClickableSpan.class); if (links.length != 0) &#123; ClickableSpan link = links[0]; if (action == MotionEvent.ACTION_UP) &#123; // 不认识，不管它。 if (link instanceof TextLinkSpan) &#123; ((TextLinkSpan) link).onClick( widget, TextLinkSpan.INVOCATION_METHOD_TOUCH); &#125; else &#123; // 手指抬起时回调onClick方法。 link.onClick(widget); &#125; &#125; else if (action == MotionEvent.ACTION_DOWN) &#123; // 按下设置一下选中样式。也就是光标。 if (widget.getContext().getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.P) &#123; // Selection change will reposition the toolbar. Hide it for a few ms for a // smoother transition. widget.hideFloatingToolbar(HIDE_FLOATING_TOOLBAR_DELAY_MS); &#125; Selection.setSelection(buffer, buffer.getSpanStart(link), buffer.getSpanEnd(link)); &#125; return true; &#125; else &#123; // 清除选中样式。也就是光标。 Selection.removeSelection(buffer); &#125; &#125; return super.onTouchEvent(widget, buffer, event); &#125; 所以LinkMovementMethod也是根据触摸的位置找出ClickableSpan（同一个位置设置多个的话，也只会执行第一个），然后回调onClick。LinkMovementMethod是被TextView回调。看到这里ClickableSpan的实现原理基本就清楚了。 其他方案有个大胆的想法💡：我先自定义只带数据和样式的span。再定义一个 MySpanListener 里面有个方法onClick(v:View,data:Data)。然后自定义LinkMovementMethod（比如叫MyMovementMethod）。同上在onTouchEvent里找出自己定义span。然后根据textView拿到listener。回调onClick(v:View,data:Data)方法。那么问题是红字的怎么去实现（主要问题是listener，以什么维度储存，怎么储存）。比如在MyMovementMethod里设置一个弱引用的map：WeakHashMap&lt;TextView,MySpanListener&gt; 也是一种方法，但是看起来挺别扭。哈。。。 另一个问题LinkMovementMethod有个很大的问题，就是长按时。依旧会回调onClick方法。这就会出现交互伤的bug。解决方案：123456789101112131415161718192021222324252627282930313233343536373839object ClickLinkMovementMethod : LinkMovementMethod() &#123; private const val CLICK_DELAY = 500L private var lastClickTime: Long = 0 override fun onTouchEvent(widget: TextView?, buffer: Spannable?, event: MotionEvent?): Boolean &#123; event ?: return false widget ?: return false val action = event.action if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) &#123; var x = event.x.toInt() var y = event.y.toInt() x -= widget.totalPaddingLeft y -= widget.totalPaddingTop x += widget.scrollX y += widget.scrollY val layout: Layout = widget.layout val line: Int = layout.getLineForVertical(y) val off: Int = layout.getOffsetForHorizontal(line, x.toFloat()) val link: Array&lt;ClickableSpan&gt; = buffer?.getSpans(off, off, ClickableSpan::class.java) ?: return true if (link.isNotEmpty()) &#123; if (action == MotionEvent.ACTION_UP) &#123; if (System.currentTimeMillis() - lastClickTime &lt; CLICK_DELAY) &#123; link[0].onClick(widget) &#125; &#125; else if (action == MotionEvent.ACTION_DOWN) &#123; lastClickTime = System.currentTimeMillis() Selection.setSelection(buffer, buffer.getSpanStart(link[0]), buffer.getSpanEnd(link[0])) &#125; return true &#125; else &#123; Selection.removeSelection(buffer) &#125; &#125; return false &#125;&#125; 总结： ClickableSpan实现点击监听的原理是LinkMovementMethod。 LinkMovementMethod存在长按时交互的bug。 ClickableSpan的数据&amp;事件分离依旧期望更优质的方案。","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"Fragment 监听返回按键","date":"2020-05-11T05:00:30.000Z","path":"2020/05/11/android_4/","text":"监听返回键Android开发中，我们用fragment承担页面UI主要的逻辑，简化activity逻辑。有个场景，fragment需要监听返回键。但fragment不像activity能感知物理按键。 过去我们会写一个监听接口，让fragment实现。然后activity遍历（或根据tag）找到需要的fragment，在按返回键时，主动将事件下发给fragment。 虽然实现了fragment监听返回键的效果，但是代码需要侵入到activity，并不利于维护。google官方也考虑到了这个问题。 现在在新版的AndroidX中：ComponentActivity中增加了OnBackPressedDispatcher（用于注册返回键监听）。 activity继承关系如下： 新的fragment监听方案： 关键类：OnBackPressedCallback，OnBackPressedDispatcher，ComponentActivity。 1234567// 定义返回键监听事件。val callback = object : OnBackPressedCallback(false) &#123; override fun handleOnBackPressed() &#123; //do some thing &#125; &#125; 1234// 注册监听事件。activity为ComponentActivity的子类对象即可。并绑定生命周期。activity.onBackPressedDispatcher.addCallback(lifecycleOwner, callback)// 也可以不绑定生命周期。activity.onBackPressedDispatcher.addCallback(callback) OnBackPressedCallback可以设置enabled，可以灵活控制要不要消费返回键点击事件。 优势所有代码都在fragment里。不需要要求activity写多余的逻辑。只要能拿到activity对象和所在的lifecycleOwner即可完成监听任务。甚至是在自定义view中。 深入源码OnBackPressedCallback：用于处理OnBackPressedDispatcher.onBackPressed()回调而无需将该实现与的子类强耦合的类ComponentActivity。源码比较简单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public abstract class OnBackPressedCallback &#123; private boolean mEnabled; private CopyOnWriteArrayList&lt;Cancellable&gt; mCancellables = new CopyOnWriteArrayList&lt;&gt;(); /** * Create a &#123;@link OnBackPressedCallback&#125;. * * @param enabled The default enabled state for this callback. * @see #setEnabled(boolean) */ public OnBackPressedCallback(boolean enabled) &#123; mEnabled = enabled; &#125; /** * Set the enabled state of the callback. Only when this callback * is enabled will it receive callbacks to &#123;@link #handleOnBackPressed()&#125;. * &lt;p&gt; * Note that the enabled state is an additional layer on top of the * &#123;@link androidx.lifecycle.LifecycleOwner&#125; passed to * &#123;@link OnBackPressedDispatcher#addCallback(LifecycleOwner, OnBackPressedCallback)&#125; * which controls when the callback is added and removed to the dispatcher. * * @param enabled whether the callback should be considered enabled */ @MainThread public final void setEnabled(boolean enabled) &#123; mEnabled = enabled; &#125; /** * Checks whether this callback should be considered enabled. Only when this callback * is enabled will it receive callbacks to &#123;@link #handleOnBackPressed()&#125;. * * @return Whether this callback should be considered enabled. */ @MainThread public final boolean isEnabled() &#123; return mEnabled; &#125; /** * Removes this callback from any &#123;@link OnBackPressedDispatcher&#125; it is currently * added to. */ @MainThread public final void remove() &#123; for (Cancellable cancellable: mCancellables) &#123; cancellable.cancel(); &#125; &#125; /** * Callback for handling the &#123;@link OnBackPressedDispatcher#onBackPressed()&#125; event. */ @MainThread public abstract void handleOnBackPressed(); void addCancellable(@NonNull Cancellable cancellable) &#123; mCancellables.add(cancellable); &#125; void removeCancellable(@NonNull Cancellable cancellable) &#123; mCancellables.remove(cancellable); &#125;&#125; OnBackPressedDispatcher：存放监听的容器，通过它统一执行。 储存结构： 123// 利用一个队列存储回调。 @SuppressWarnings(\"WeakerAccess\") /* synthetic access */final ArrayDeque&lt;OnBackPressedCallback&gt; mOnBackPressedCallbacks = new ArrayDeque&lt;&gt;(); 是否有有效回调：1234567891011@MainThread public boolean hasEnabledCallbacks() &#123; Iterator&lt;OnBackPressedCallback&gt; iterator = mOnBackPressedCallbacks.descendingIterator(); while (iterator.hasNext()) &#123; if (iterator.next().isEnabled()) &#123; return true; &#125; &#125; return false; &#125; 执行顺序：12345678910111213141516// 按先注册顺序遍历，只执行enabled为true的回调。@MainThread public void onBackPressed() &#123; Iterator&lt;OnBackPressedCallback&gt; iterator = mOnBackPressedCallbacks.descendingIterator(); while (iterator.hasNext()) &#123; OnBackPressedCallback callback = iterator.next(); if (callback.isEnabled()) &#123; callback.handleOnBackPressed(); return; &#125; &#125; if (mFallbackOnBackPressed != null) &#123; mFallbackOnBackPressed.run(); &#125; &#125; 绑定生命周期原理：12345678910@MainThread public void addCallback(@NonNull LifecycleOwner owner, @NonNull OnBackPressedCallback onBackPressedCallback) &#123; Lifecycle lifecycle = owner.getLifecycle(); if (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) &#123; return; // 无视已经死亡的。 &#125; onBackPressedCallback.addCancellable( new LifecycleOnBackPressedCancellable(lifecycle, onBackPressedCallback)); &#125; LifecycleOnBackPressedCancellable 监听生命周期变化，决定是否cancel掉监听。12345678910111213141516171819202122232425262728293031323334353637private class LifecycleOnBackPressedCancellable implements LifecycleEventObserver, Cancellable &#123; private final Lifecycle mLifecycle; private final OnBackPressedCallback mOnBackPressedCallback; @Nullable private Cancellable mCurrentCancellable; LifecycleOnBackPressedCancellable(@NonNull Lifecycle lifecycle, @NonNull OnBackPressedCallback onBackPressedCallback) &#123; mLifecycle = lifecycle; mOnBackPressedCallback = onBackPressedCallback; lifecycle.addObserver(this); &#125; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; if (event == Lifecycle.Event.ON_START) &#123; // 此时为有效。 mCurrentCancellable = addCancellableCallback(mOnBackPressedCallback); &#125; else if (event == Lifecycle.Event.ON_STOP) &#123; // Should always be non-null if (mCurrentCancellable != null) &#123; mCurrentCancellable.cancel(); &#125; &#125; else if (event == Lifecycle.Event.ON_DESTROY) &#123; cancel(); &#125; &#125; @Override public void cancel() &#123; mLifecycle.removeObserver(this); mOnBackPressedCallback.removeCancellable(this); if (mCurrentCancellable != null) &#123; mCurrentCancellable.cancel(); mCurrentCancellable = null; &#125; &#125; &#125; ComponentActivity： 关键代码：1234567891011121314// 父类的 onBackPressed 事件委托给 OnBackPressedDispatcher 。private final OnBackPressedDispatcher mOnBackPressedDispatcher = new OnBackPressedDispatcher(new Runnable() &#123; @Override public void run() &#123; ComponentActivity.super.onBackPressed(); &#125; &#125;);// 自己的 onBackPressed 全交给 OnBackPressedDispatcher 处理。@Override @MainThread public void onBackPressed() &#123; mOnBackPressedDispatcher.onBackPressed(); &#125; 总结利用注册监听的方式，可以很好的结偶代码，可以activity的功能分发到各个能够访问activity对象的组件上。","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"LiveData实现消息总线","date":"2020-05-10T07:04:30.000Z","path":"2020/05/10/android_3/","text":"消息总线Android开发中，我们常遇见不同页面之间要保持数据同步。送最初的onActivityResult，到后面的第三方库EventBus，RxBus,LiveEventBus。现在我们需要利用livedata自己写一个简单的消息总线。 对比过去：onActivityResult：使用较为繁琐，并且在多页面下（比如栈：A,B,C。C的事件要传递给A就使用不方便了)。EventBus：时代的眼泪，使用方便，但性能内存体积都是缺陷。RxBus：不是库，是个文件，实现只有短短30行代码。结合Rxjava可以很方便的使用。LiveEventBus：利用系统的livedata。体积小。且可以感知生命周期。消息总线 | 延迟发送 | 有序接收消息 | Sticky | 生命周期感知 | 跨进程/APP | 线程分发-|-|-|-|-|-|-EventBus | ❌ | ✅ | ✅ | ❌ | ❌ | ✅RxBus | ❌ | ❌ | ✅ | ❌ | ❌ | ✅LiveEventBus | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ 它们都很优秀。但我们不用它们。自己写个简单的实现方案。主要参考LiveEventBus的核心逻辑。 代码：短短50多行代码（去掉注释和空行也就30行左右）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849object EventHelper &#123; private val map = HashMap&lt;String, EventLiveData&lt;*&gt;&gt;() @Suppress(\"UNCHECKED_CAST\") fun &lt;T&gt; with(key: String, type: Class&lt;T&gt;? = null): EventLiveData&lt;T&gt; &#123; if (!map.containsKey(key)) &#123; map[key] = EventLiveData&lt;T&gt;() &#125; return map[key] as? EventLiveData&lt;T&gt; ?: throw RuntimeException(\"cannot cast EventLiveData of \" + type.toString()) &#125; /** * 记录版本的 MutableLiveData。 */ class EventLiveData&lt;T&gt; : MutableLiveData&lt;T&gt;() &#123; var version: Int = 0 private set /** * postValue 最终也会调 setValue ，所以只需要在这里统计 version。 */ override fun setValue(value: T) &#123; version++ super.setValue(value) &#125; /** * 订阅事件。绑定生命周期。返回 Observer 方便主动移除观察。 */ fun observeEvent(owner: LifecycleOwner, onEvent: (T) -&gt; Unit): Observer&lt;T&gt; &#123; return EventObserver(onEvent).apply &#123; super.observe(owner, this) &#125; &#125; /** * 订阅事件。永久有效。返回 Observer 方便主动移除观察。 */ fun observeForeverEvent(onEvent: (T) -&gt; Unit): Observer&lt;T&gt; &#123; return EventObserver(onEvent).apply &#123; super.observeForever(this) &#125; &#125; /** * 不接收创建之前的消息。 */ inner class EventObserver&lt;T&gt;(val onEvent: (T) -&gt; Unit) : Observer&lt;T&gt; &#123; private var observerVersion = this@EventLiveData.version override fun onChanged(t: T) &#123; if (observerVersion &lt; this@EventLiveData.version) &#123; observerVersion = this@EventLiveData.version onEvent(t) &#125; &#125; &#125; &#125;&#125; 使用姿势：1234567891011// 获取：(一般会把这步封装起来）EventHelper.with&lt;Event&gt;(Key) //or EventHelper.with(Key,Event::class.java)// 订阅：observeEvent(owner)&#123; event -&gt; do something &#125; // 绑定生命周期。observeForeverEvent&#123; event -&gt; do something &#125; // 永久有效。// 发布：setValue(event) // 主线程。postValue(event) // 子线程。// 移除：同liveData。 实战： 封装：同一模块的事件放在一起。key 与 event 对应。 key 命名规范：模块名+子模块名+具体事件。 event类上加上ID：例如：ChangeGroupNameEvent加上groupCode明确是那个群名称变了。123456789101112131415161718192021222324252627282930313233// 示例object IMEventHelper &#123; private const val CHANGE_GROUP_NAME = \"im/group/changeGroupName\" private const val CHANGE_NOTIFICATION = \"im/group/changeNotification\" private const val CHANGE_MEMBER_LIST = \"im/group/changeMemberList\" private const val CHANGE_GROUP_LIST = \"im/group/changeGroupList\" private const val QUIT_GROUP = \"im/group/quitGroup\" private const val CHOOSE_AT = \"im/group/chooseAt\" /** * 群名称修改。 */ fun changeGroupName() = EventHelper.with&lt;ChangeGroupNameEvent&gt;(CHANGE_GROUP_NAME) /** * 公告修改。 */ fun changeNotification() = EventHelper.with&lt;ChangeNotificationEvent&gt;(CHANGE_NOTIFICATION) /** * 成员列表变换。 */ fun changeMemberList() = EventHelper.with&lt;ChangeMemberListEvent&gt;(CHANGE_MEMBER_LIST) /** * 群聊列表变换。 */ fun changeGroupList() = EventHelper.with&lt;ChangeGroupListEvent&gt;(CHANGE_GROUP_LIST) /** * 退出群聊。 */ fun quitGroup() = EventHelper.with&lt;QuitGroupEvent&gt;(QUIT_GROUP) /** * 选择AT 成员。 */ fun chooseAt() = EventHelper.with&lt;AtMemberEvent&gt;(CHOOSE_AT)&#125; event类：1class ChangeGroupNameEvent(val groupCode: String, val newName: String) 使用：12345678// 在 fragment 初始化里订阅事件。IMEventHelper .changeGroupName() .observeEvent(this) &#123; vm.changeName(it) &#125;// 在 其它地方发布事件。IMEventHelper .changeGroupName() .postValue(ChangeGroupNameEvent(groupCode, newName)) 总结：要点： 利用LiveData，感知生命周期的特性。 不接收注册观察之前的消息。 缺点： Livedata只能保证接收到最新的数据。中间的数据可不管哦。😯","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"kotlin使用let报java.lang.NoClassDefFoundError","date":"2019-11-13T08:27:00.000Z","path":"2019/11/13/kotlin_1/","text":"问题阐述kotlin 运行这段代码报java.lang.NoClassDefFoundError错误（表示运行中找不到类的定义）。如下代码： 1234567891011121314151617private fun shareUrlToFriend(logoUrl: String) &#123; activity?.let &#123; Glide.with(this) .asBitmap() .load(logoUrl) .into(object : CustomTarget&lt;Bitmap&gt;() &#123; override fun onLoadCleared(placeholder: Drawable?) &#123; &#125; override fun onResourceReady(resource: Bitmap, transition: Transition&lt;in Bitmap&gt;?) &#123; print(logoUrl)//就是一个方法使用了logoUrl &#125; &#125;) &#125; &#125; 经过替换尝试，报错不是Glide的锅。根据kotlin默认最后一行是返回值的规则，这代码最后let下面最后一个返回对象是CustomTarget的匿名内部类对象。因为：12345// Glide into()方法@NonNull public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(@NonNull Y target) &#123; return into(target, /*targetListener=*/ null, Executors.mainThreadExecutor()); &#125; 所以，可以把上面代码替换成如下简单代码：1234567891011121314151617181920212223class T &#123; var a: Any? = null fun f(u: String) &#123; a?.let &#123; object : Inter &#123; override fun e() &#123; print(u) &#125; &#125; &#125; &#125;&#125;fun main() &#123; val t = T() t.a = Any() t.f(\"u\")&#125;interface Inter &#123; fun e()&#125; 这段执行f()函数代码会报一样的错误。123456789101112Exception in thread \"main\" java.lang.NoClassDefFoundError: com/a/wzm/shere/ui/T$f$1$1 at com.a.wzm.shere.ui.T.f(Test.kt:14) at com.a.wzm.shere.ui.TestKt.main(Test.kt:28) at com.a.wzm.shere.ui.TestKt.main(Test.kt)Caused by: java.lang.ClassNotFoundException: com.a.wzm.shere.ui.T$f$1$1 at java.net.URLClassLoader.findClass(URLClassLoader.java:382) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 3 moreProcess finished with exit code 1 T$f$1$1是个什么鬼？ 问题追溯查看翻译后的Java代码：1234567891011//NO.0 主要看f()函数。public final void f(@NotNull String u) &#123; Intrinsics.checkParameterIsNotNull(u, \"u\"); if (this.a != null) &#123; boolean var3 = false; boolean var4 = false; int var6 = false; 1 var10000 = (1)(new T$f$$inlined$let$lambda$1(u));// 1是啥？ &#125; &#125; 里面这个1就是不没定义的类型（也就是报错里面需要定义的T$f$1$1）。为什么有个1出来捣乱?12345678910111213141516171819202122//生成的类。@Metadata( mv = &#123;1, 1, 15&#125;, bv = &#123;1, 0, 3&#125;, k = 1, d1 = &#123;\"\\u0000\\u0011\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000*\\u0001\\u0000\\b\\n\\u0018\\u00002\\u00020\\u0001J\\b\\u0010\\u0002\\u001a\\u00020\\u0003H\\u0016¨\\u0006\\u0004¸\\u0006\\u0000\"&#125;, d2 = &#123;\"com/a/wzm/shere/ui/Te$f$1$1\", \"Lcom/a/wzm/share/ui/Inter;\", \"a\", \"\", \"app\"&#125;)public final class Te$f$$inlined$let$lambda$1 implements Inter &#123; // $FF: synthetic field final String $u$inlined; Te$f$$inlined$let$lambda$1(String var1) &#123; this.$u$inlined = var1; &#125; public void a() &#123; String var1 = this.$u$inlined; boolean var2 = false; System.out.print(var1); &#125;&#125; 类名跟注解里的（&quot;com/a/wzm/share/ui/Te$f$1$1&quot;）不一致。 实验对上诉代码简单修改测试。发现只需要简单修改就不报错。比如： 不用 let第一行用if(a==null)return。（规避了let的问题，不讨论）。 a后面的?去掉。 方法e()里不使用u object: Inter前面加上val x=进行赋值掉。 在let最后一行写个1，true或其他明确类型的东西。 而这样做，报一样错误。 a?.let前面加val c=进行赋值操作。此时就算?（如2所诉） 去掉也报错。结合3，4，5不报错。 把上诉实验通过转换，查看翻译后的Java代码：123456789// NO.2 public final void f(@NotNull String u) &#123; Intrinsics.checkParameterIsNotNull(u, \"u\"); Object var2 = this.a; boolean var3 = false; boolean var4 = false; int var6 = false; new T$f$$inlined$let$lambda$1(u); &#125; 123456789101112//NO.3public final void f(@NotNull String u) &#123; Intrinsics.checkParameterIsNotNull(u, \"u\"); if (this.a != null) &#123; boolean var3 = false; boolean var4 = false; int var6 = false; new T$f$1$1(); &#125; else &#123; Object var10000 = null; &#125; &#125; 1234567891011//NO.4public final void f(@NotNull String u) &#123; Intrinsics.checkParameterIsNotNull(u, \"u\"); if (this.a != null) &#123; boolean var3 = false; boolean var4 = false; int var6 = false; new T$f$$inlined$let$lambda$1(u); &#125; &#125; 123456789101112//NO.5，最后一行加了个truepublic final void f(@NotNull String u) &#123; Intrinsics.checkParameterIsNotNull(u, \"u\"); if (this.a != null) &#123; boolean var3 = false; boolean var4 = false; int var6 = false; new T$f$$inlined$let$lambda$1(u); boolean var10000 = true; &#125; &#125; 123456789//NO.6 又出现未知类型：1public final void f(@NotNull String u) &#123; Intrinsics.checkParameterIsNotNull(u, \"u\"); Object var3 = this.a; boolean var4 = false; boolean var5 = false; int var7 = false; 1 x = (1)(new T$f$$inlined$let$lambda$1(u)); &#125; 区别 匿名类 是否出现类型（1） NO.0（原始） T$f$$inlined$let$lambda$1 是 NO.2 T$f$$inlined$let$lambda$1 否 NO.3 T$f$1$1 否 NO.4 T$f$$inlined$let$lambda$1 否 NO.5 T$f$$inlined$let$lambda$1 否 NO.6 T$f$$inlined$let$lambda$1 是 首先分析第4点和第5点。第4点把匿名类对象赋值给了x，这意味这let只能取下一行做返回值（没有下行，就是Unit）。所以也就是说let有明确返回值就不报错。没有明确返回值类型且“不关心”返回值（如NO.2)，也不会错。NO.0也不“关心”返回值啊？可是NO.0又对a的空判断，对let返回又两种结果，要么有返回，要么没返回，将也它归纳为“关心”结果。至于NO.3的情况（就算结合NO.6也不报错），生成的类就是NO.0中报错中没定义的类（为什么会这样，稍后讨论）。所以也就没问题了。 问题1为什么let“关心”返回值会有区别？let的返回值究竟是个啥？ 分析首先，查看let方法的定义。1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block(this)&#125; let 是泛型的扩展方法，参数是个高阶函数。作用是将一种类型T，通过block方法变换变成类型R。 所以let返回值是个R。那R是什么呢？ 当然是自己定喽。我们一直都是直接用let，实际上严格用法应该这样：1234val a = 1val s = a.let&lt;Int, String&gt; &#123; return@let it.toString()&#125; 只不过，kotlin的自动类型识别帮我们做了类型区分。 问题中的类型1估计就是不明确的R。所以我们手动指定累行试试。123456789fun f(u: String) &#123; a?.let&lt;Any, Inter&gt; &#123; object : Inter &#123; override fun a() &#123; print(u) &#125; &#125; &#125; &#125; 对应的Java代码。 123456789public final void f(@NotNull String u) &#123; Intrinsics.checkParameterIsNotNull(u, \"u\"); if (this.a != null) &#123; boolean var3 = false; boolean var4 = false; int var6 = false; Inter var10000 = (Inter)(new T$f$$inlined$let$lambda$1(u)); &#125; &#125; 原本是1的地方变成了我们指定的类型Inter。代码跑起来也不在跌跟斗。 那为什么“不关心”结果的时候翻译过来就不需要转 R 的类型呢？（目前找到的解释是编译器优化掉明确不需要的过程） 问题2看这个问题之前，我们应该发现了，let里的代码直接被拷到f()函数里面，而不是生成高阶函数block: (T) -&gt; R表示的接口的实现类。而且Inter本该内部类的实现，也变成了定义了外部独立的类。为什么会这样？ 解释这是因为inline关键字的作用：inline 的工作原理就是将内联函数的函数体复制到调用处实现内联。详情见参考资料。 实验写一个没有inline的仿let方法，再替换原let。123fun &lt;T, R&gt; T.mylet(block: (T) -&gt; R): R &#123; return block(this)&#125; 12345678910//No.7fun f(u: String) &#123; a?.mylet &#123; object : Inter &#123; override fun a() &#123; print(u) &#125; &#125; &#125; &#125; 运行不报错，看法Java代码。123456789101112131415161718192021222324252627//NO.7public final void f(@NotNull final String u) &#123; Intrinsics.checkParameterIsNotNull(u, \"u\"); Object var10000 = this.a; if (var10000 != null) &#123; &lt;undefinedtype&gt; var2 = (&lt;undefinedtype&gt;)TestKt.mylet(var10000, (Function1)(new Function1() &#123; // $FF: synthetic method // $FF: bridge method public Object invoke(Object var1) &#123; return this.invoke(var1); &#125; @NotNull public final &lt;undefinedtype&gt; invoke(@NotNull Object it) &#123; Intrinsics.checkParameterIsNotNull(it, \"it\"); return new Inter() &#123; public void a() &#123; String var1 = u; boolean var2 = false; System.out.print(var1); &#125; &#125;; &#125; &#125;)); &#125; &#125; 内部用Function1 代表block: (T) -&gt; R表示的接口的实现类。Inter依旧是内部类的方式实现。 可见，inline关键字在处理方法体中的内部类，做了明显的优化处理（即生成一个独立的外部类）。 问题3结合问题1中的NO.3和问题2以及实验，发现Inter中用到let外部信息时，生成的类是T$f$$inlined$let$lambda$1（但后面还会强转为T$f$1$1，也就是那个1，然后报找不到类的定义的错误），而不使用外部的信息时，生成的类是T$f$1$1。区分度是什么？ 猜想通过inline内联函数传入的lambda表达式生成的匿名类，如果有指向外部的变量，那么命名为：class + method + inlined + method + lambda + number。如果没有，命名为： class + method + number + number（第一个number表示let同层级编号，第二个number表示内部类的编号。而然运行中外部类在执行checkcast的时候，还是按照旧的规则去组装命名。（仅为猜想，未得原因） ##结论其实还没有具体结论！遇到此类问题，大胆猜想，动手实践，总结规律。","tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://wzmyyj.top/tags/kotlin/"}]},{"title":"仿知音漫客漫画APP--MVP模式","date":"2018-08-22T05:11:12.000Z","path":"2018/08/22/android_2/","text":"ZYMK（漫画app）一款采用MVP的仿《知音漫客》漫画APP。 mvp + rxjava + retrofit + okhttp + greendao + glide + gson + jsoup + eventbus + butterknife 项目地址：https://github.com/wzmyyj/ZYMK 最新更新（2018.06.19） 由常规MVP改为Google推荐的MVP-Contract模式。将原本的presenter层每个类抽象出接口，并将这些接口和对应的view的接口，放在同一个contract接口里（接口里放两个接口）。 抽象出p层接口使v层依赖于p层接口（父类）。依赖倒转原则。 使用contract好处是p层与v层相互调用关系在一个文件里一目了然。下次会详细介绍这种模式。 修改了一些命名规范，类名，方法名等。 修改了一些类实现的方法，修复一个小bug。 Apk下载：链接：https://pan.baidu.com/s/1Gp5vcoUx7NEr8n17nM8wwg 密码：b6zq 项目地址：https://github.com/wzmyyj/ZYMK 效果图： 免责声明：本程序所有资源全部来源于网络爬虫,且规避了付费的漫画，所有的漫画在网络可以免费阅读的。本程序仅供学习参考使用，严禁任何商业用途。欢迎各位进行技术讨论和交流。如果侵犯到任何人的利益，可以联系作者QQ：2018987032。进行协商，进行漫画的下架。 博客：同步于简书：https://www.jianshu.com/p/80c8541387de","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"【算法】葱的战争一道算法题","date":"2018-07-08T08:21:29.000Z","path":"2018/07/08/java_3/","text":"前段时间，同学给看了一道，某个历年的考研机试算法题。我想用面向对象的方法去实现。 题目 一个m*n的棋盘，上面有k根葱，每根葱面朝方向为d（0123分别表示上下左右），每根葱一个战斗力f。每隔时间葱会向面朝方向走一格， 如果遇到棋盘边界，那么他将把面朝方向转180度（此回合葱不会走动），如果某个时刻有两个或以上的葱在同一位置，那么他们将发生 战争，只有战斗力最高的葱存活，其他的葱全部原地枯萎，不在走动，求经过t时间后所有葱的位置。 输入：第一行m n k，然后接下来k行每根葱的信息x y d f（坐标，方向，战斗力），最后一行输入时间t。 输出：k行，分别表示每个葱的位置。 数据范围：m和n在100内，k在1000内，t在1000内，f在1000内，保证初始每颗葱位置不同，战斗力不同。 面向对象 建一个Cong（葱）类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Cong &#123;// 葱 private int x; private int y; private int d; private int f; private boolean isLive = true; public Cong(int x, int y, int d, int f) &#123; super(); this.x = x; this.y = y; this.d = d; this.f = f; this.isLive = true;// 默认存活 &#125; // 此处省略 set 和get 方法 public void go() &#123;// 走 if (!isLive) return; switch (d) &#123; case 0: y++; break; case 1: y--; break; case 2: x--; break; case 3: x++; break; &#125; &#125; public void turn() &#123;// 转向 if (!this.isLive) return; switch (d) &#123; case 0: d = 1; break; case 1: d = 0; break; case 2: d = 3; break; case 3: d = 2; break; &#125; &#125; public void fight(Cong c) &#123;// 打架 if (!this.isLive || !c.isLive())// 死了没？ return; if (this.x == c.getX() &amp;&amp; this.y == c.getY()) &#123;// 遇见没？ if (this.f &gt; c.getF()) &#123; c.setLive(false); &#125; else if (this.f &lt; c.getF()) &#123; this.setLive(false); &#125; else &#123; this.setLive(false); c.setLive(false); &#125; &#125; &#125;&#125; Pan（棋盘）类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Pan &#123;// 棋盘 private int m; private int n; private List&lt;Cong&gt; g; public Pan(int m, int n, List&lt;Cong&gt; g) &#123; super(); this.m = m; this.n = n; this.g = g; &#125; public void run() &#123; for (Cong c : g) &#123; if (!c.isLive())// 死亡 continue; war(c);// 战争 if (isTurn(c)) &#123;// 行动 c.turn(); &#125; else &#123; c.go(); &#125; &#125; &#125; public boolean isTurn(Cong c) &#123;// 是否转向 if (c.getX() == 0 &amp;&amp; c.getD() == 2) return true; if (c.getX() == m - 1 &amp;&amp; c.getD() == 4) return true; if (c.getY() == 0 &amp;&amp; c.getD() == 1) return true; if (c.getX() == n - 1 &amp;&amp; c.getD() == 0) return true; return false; &#125; public void war(Cong c) &#123; for (Cong c1 : g) &#123; if (c != c1)// 不跟自己打 c.fight(c1); &#125; &#125;&#125; 客户端代码 12345678910111213141516171819202122232425262728293031323334public class Client &#123;// 客户端 public static void main(String[] args) &#123; // 输入 Scanner can = new Scanner(System.in); int m = can.nextInt(); int n = can.nextInt(); int k = can.nextInt(); List&lt;Cong&gt; g = new ArrayList&lt;Cong&gt;(); for (int i = 0; i &lt; k; i++) &#123; int x = can.nextInt(); int y = can.nextInt(); int d = can.nextInt(); int f = can.nextInt(); Cong c = new Cong(x, y, d, f); g.add(c); &#125; int t = can.nextInt(); can.close(); // 逻辑操作 Pan p = new Pan(m, n, g); for (int i = 0; i &lt; t; i++) &#123;// 执行t次 p.run(); &#125; // 输出 for (int i = 0; i &lt; k; i++) &#123; Cong c = g.get(i); System.out.print(c.getX() + \" \" + c.getY() + \"\\n\"); &#125; &#125;&#125; 附页源码地址：https://github.com/wzmyyj/CongWar","tags":[{"name":"java","slug":"java","permalink":"https://wzmyyj.top/tags/java/"}]},{"title":"小故事：蚂蚁的抉择","date":"2018-07-01T09:20:00.000Z","path":"2018/07/01/story_1/","text":"故事一天，一只小蚂蚁，来到一个三叉路口。 左边的路过去，会有一块香甜的奶酪。但是，路的另一端，有一只更大的蚂蚁正在慢慢靠近，虽然它的距离更远些。也就是说，如果过去吃奶酪，只能吃上几口，然后需要与大蚂蚁打一架，决定是否得到剩余的大半奶酪。 右边的路过去，在更远的一处，也有一块类似的奶酪。但是，没法确定那边是否有其他蚂蚁。如果有，也不确定是否比自己大，是否打得过它。 那时，… 小蚂蚁没有过去，而是回头去了别的地方。到了别的地方，小蚂蚁发现了一块能吃了可以慢慢变回来的奶酪。小蚂蚁高兴的品尝着这份甜蜜，吃得差不多了，先把剩下的留着，它会自己慢慢变回来。此后，小蚂蚁往往只过一段时间吃几口。 最后，… 有那么一天，奶酪被命运夺走了。","tags":[{"name":"故事","slug":"故事","permalink":"https://wzmyyj.top/tags/故事/"}]},{"title":"关于HTTP协议你需要知道这些","date":"2018-06-09T03:45:50.000Z","path":"2018/06/09/it_5/","text":"HTTP超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。 HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 主要特征 支持B/S及C/S模式。 简单快速：2.1 客户向服务器请求服务时，只需传送请求方法和路径。2.2 请求方法常用的有GET、HEAD、POST等，分别规定了客户与服务器不同的联系类型。2.3 HTTP协议简单，使得HTTP服务器的程序规模小，通信速度快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 请求方法一共有八种请求方式： GET向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 HEAD与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 POST向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT向指定资源位置上传其最新内容。 DELETE请求服务器删除Request-URI所标识的资源。 TRACE回显服务器收到的请求，主要用于测试或诊断。 OPTIONS这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 响应HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 状态行HTTP-Version Status-Code Reason-Phrase CRLF1.1 HTTP-Version表示服务器HTTP协议的版本；1.2 Status-Code表示服务器发回的响应状态代码；1.3 Reason-Phrase表示状态代码的文本描述。 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常见状态代码、状态描述、说明：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常其他代码请参考这篇 1例如：HTTP/1.1 200 OK （CRLF） 消息报头内容较长，请参考HTTP协议详解（真的很经典） 响应正文就是服务器返回的资源的内容。 协议例子下面是一个HTTP客户端与服务器之间会话的例子，运行于www.google.com，端口80。 请求信息发出的请求信息（message request）包括以下几个: 请求行（例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件）。 请求头（例如Accept-Language: en）。 空行。 其他消息体。 请求行和标题必须以作为结尾。空行内必须只有而无其他空格。在HTTP/1.1协议中，所有的请求头，除Host外，都是可选的。 客户端请求12GET / HTTP/1.1Host: www.google.com （末尾有一个空行。第一行指定方法、资源路径、协议版本；第二行是在1.1版里必带的一个header作用指定主机） 服务器应答123456789HTTP/1.1 200 OKContent-Length: 3059Server: GWS/2.0Date: Sat, 11 Jan 2003 02:44:04 GMTContent-Type: text/htmlCache-control: privateSet-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqyX9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.comConnection: keep-alive （紧跟着一个空行，并且由HTML格式的文本组成了Google的主页） 版本超文本传输协议（HTTP）已经演化出了很多版本，它们中的大部分都是向下兼容的。在 RFC 2145 中描述了HTTP版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。 HTTP/0.9已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。 HTTP/1.0这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。 HTTP/1.1持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。HTTP/1.1相较于HTTP/1.0协议的区别主要体现在： 缓存处理 带宽优化及网络连接的使用 错误通知的管理 消息在网络中的发送 互联网地址的维护 安全性及完整性 在HTTP 0.9和1.0中，TCP连接在每一次请求/回应对之后关闭。在HTTP 1.1中，引入了保持连接的机制，一个连接可以重复在多个请求/回应使用。持续连接的方式可以大大减少等待时间，因为在发出第一个请求后，双方不需要重新运行TCP交握程序。 HTTP/2当前版本，于2015年5月作为互联网标准正式发布。 TCP/IP尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。","tags":[{"name":"IT","slug":"IT","permalink":"https://wzmyyj.top/tags/IT/"}]},{"title":"Java获取中文首字母","date":"2018-06-08T08:21:29.000Z","path":"2018/06/08/java_2/","text":"中文首字母有时候，比如微信上根据名字拼音首字母排序并检索。那么用Java获取中文首字母是怎么实现的呢？ 代码不多说，直接上代码：（写个工具类）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class FirstCharUtil &#123; // 简体中文的编码范围从B0A1（45217）一直到F7FE（63486） private static int BEGIN = 45217; private static int END = 63486; // 按照声 母表示，这个表是在GB2312中的出现的第一个汉字， //也就是说“啊”是代表首字母a的第一个汉字。 // i, u, v都不做声母, 自定规则跟随前面的字母 private static char[] charTable = &#123; '啊', '芭', '擦', '搭', '蛾', '发', '噶', '哈', '哈', '击', '喀', '垃', '妈', '拿', '哦', '啪', '期', '然', '撒', '塌', '塌', '塌', '挖', '昔', '压', '匝', &#125;; // 二十六个字母区间对应二十七个端点 // GB2312码汉字区间十进制表示 private static int[] table = new int[27]; // 对应首字母区间表 private static char[] initialTable = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'H', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'T', 'T', 'W', 'X', 'Y', 'Z', &#125;; // 初始化 static &#123; for (int i = 0; i &lt; 26; i++) &#123; // 得到GB2312码的首字母区间端点表，十进制。 table[i] = gbValue(charTable[i]); &#125; table[26] = END;// 区间表结尾 &#125; // ------------------------public方法区------------------------ // 根据一个包含汉字的字符串返回一个汉字拼音首字母的字符串。 public static String first(String S) &#123; String Result = \"\"; if (S == null || S.equals(\"\")) &#123; return \"#\"; &#125; char cs = S.charAt(0); try &#123; Result += Char2Initial(cs); &#125; catch (Exception e) &#123; Result = \"%\"; e.printStackTrace(); &#125; return Result; &#125; // ------------------------private方法区------------------------ /** * 输入字符,得到他的声母,英文字母返回对应的大写字母,其他非简体汉字返回 '#' */ private static char Char2Initial(char ch) &#123; // 对英文字母的处理：小写字母转换为大写，大写的直接返回 if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; return (char) (ch - 'a' + 'A'); &#125; if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; return ch; &#125; // 对非英文字母的处理：转化为首字母，然后判断是否在码表范围内， // 若不是，则直接返回。 // 若是，则在码表内的进行判断。 int gb = gbValue(ch);// 汉字转换首字母 if ((gb &lt; BEGIN) || (gb &gt; END))// 在码表区间之前，直接返回 &#123; return '#'; &#125; int i; for (i = 0; i &lt; 26; i++) &#123; // 判断匹配码表区间，匹配到就break,判断区间形如“[,)” if ((gb &gt;= table[i]) &amp;&amp; (gb &lt; table[i + 1])) &#123; break; &#125; &#125; if (gb == END) &#123;// 补上GB2312区间最右端 i = 25; &#125; return initialTable[i]; // 在码表区间中，返回首字母 &#125; /** * 取出汉字的编码 cn 汉字 */ private static int gbValue(char ch) &#123;// 将一个汉字（GB2312）转换为十进制表示。 String str = new String(); str += ch; try &#123; byte[] bytes = str.getBytes(\"GB2312\"); if (bytes.length &lt; 2) &#123; return 0; &#125; return (bytes[0] &lt;&lt; 8 &amp; 0xff00) + (bytes[1] &amp; 0xff); &#125; catch (Exception e) &#123; return 0; &#125; &#125;&#125; 使用方式：1String first = FirstCharUtil.first(\"加哇\"); 说明 原理： GB2312编码中的中文是按照拼音排序的。 注意：一些生僻的字无法获得正确的首字母，原因是这些字都是后加入的。（所以有些名字在通讯录的排序不太一样。） 其他比较好用的第三方库：汉语拼音库。1implementation 'com.belerweb:pinyin4j:2.5.1' 使用：1234567891011121314151617181920212223242526272829@NonNullpublic static String first(@Nullable String str) &#123; if (str == null || str.equals(\"\")) &#123; return \"#\"; &#125; char ch = str.charAt(0); if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; return (char) (ch - 'a' + 'A') + \"\"; &#125; if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; return ch + \"\"; &#125; try &#123; HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat(); // 设置大小写格式 defaultFormat.setCaseType(HanyuPinyinCaseType.UPPERCASE); // 设置声调格式： defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE); if (Character.toString(ch).matches(\"[\\\\u4E00-\\\\u9FA5]+\")) &#123; String[] array = PinyinHelper.toHanyuPinyinStringArray(ch, defaultFormat); if (array != null) &#123; return array[0].charAt(0) + \"\"; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"#\";&#125; HanyuPinyin（汉语拼音），太真实了😂🤣。","tags":[{"name":"java","slug":"java","permalink":"https://wzmyyj.top/tags/java/"}]},{"title":"Hexo+GitHub搭建个人博客网站","date":"2018-06-06T08:44:28.000Z","path":"2018/06/06/it_4/","text":"前言今天，带大家利用Hexo和GitHub搭建属于自己的个人博客。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。传送门：Hexo官网中文文档 环境配置1. 安装&amp;配置git 访问git官网，下载git。 双击exe文件安装，一路next即可。 安装好git之后，配置用户名和邮箱。打开git-bash： 1234# 配置全局用户名git config --global user.name \"yourname\"# 配置全局邮箱git config --global user.email \"youremail@qq.com\" 用户名和邮箱同你的GitHub（如果没有，去GitHub官网注册一个，注册好后记得邮箱验证才能使用。） 配置ssh。打开git-bash：12#输入，回车ssh-keygen 复制（右键+复制，不能ctrl+c，这里ctrl+c是结束命令的意思）图中的/c/Users/Administrator/.ssh/id_rsa，然后把它粘贴（右键+粘贴）到冒号后面，然后回车，回车，回车。。。直到结束（中间的冒号，除了第一个不用管只管回车）。 github上生成ssh key，是本地Git绑定GitHub。网页上打开github -&gt; 点击头像 -&gt; Settings -&gt; 左边菜单找到 SSH and GPG keys -&gt; New SSH key（绿色按钮）-&gt; title随便填（用英文）-&gt; key值（打开/c/Users/Administrator/.ssh/id_rsa所在的文件夹，找到id_rsa.pub，注意是pub后缀那个文件，用记事本打开，复制里面的内容，粘贴到key值。） -&gt; 点击下面的Add SSH key -&gt; 完成。 2. 下载安装Node.js node.js下载地址 安装步骤：一路默认就行（安装路径根据自己需要更改） 安装&amp;使用Hexo 在D盘下（其他地方也可以）创建一个空文件夹（命名为你主页的名字或者HEXO，随便啦，这里以名为MyBlog为例） 打开cmd命令窗口（桌面任务栏最左边那个wins图标-&gt; 搜索 -&gt; 输入cmd ，回车）。切换到D盘：（输入，回车）D: -&gt; 切换到刚才建的空文件夹：（输入，回车）cd MyBlog。 安装Hexo 1234# 切换国内源npm config set registry=\"http://registry.cnpmjs.org\"# 安装hexonpm install -g hexo 等待安装完成。 初始化Hexo：1234# 初始化Hexohexo init# 安装必要模块npm install 这时，MyBlog文件夹下就生成了一些文件。文件目录如下：1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 到此博客已经配置好了（虽然是默认的样子） 测试一下：1234# 生成静态文件hexo g // 或 hexo generate# 本地测试hexo s // 或 hexo server 然后浏览器上查看 http://localhost:4000 是不是可以看到一个简单的网页（如果不能，有可能是4000端口被别的程序占用了，自行百度解决方案）。 个性化1. _config.yml文件打开该目录下的_config.yml文件。（用什么软件打开？你可以用editplus或者vs 等，也可以直接用记事本，就是比较难看，建议下个editplus吧。） 修改成你想要的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 换成你的主页标题subtitle: 主页副标题description: 主页介绍的一句话author: 你的名字language: zh-CN #语言timezone: Asia/Shanghai #时区# URL## If your site is put in a subdirectory, ##set url as 'http://yoursite.com/child' and root as '/child/'url: http://voidking.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: pageindex_generator: per_page: 5archive_generator: per_page: 500 yearly: true monthly: true tag_generator: per_page: 100 category_generator: per_page: 100 # Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: 你用的主题文件夹名字 # themes下的文件# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: GitHub仓库地址 branch: master 2. 修改主题在hexo官网主题中找一个喜欢的主题。 找到后，一般都有介绍怎么使用该主题的文章，如果没有，把网页拉到最下面。看到：2018 | Powered by Hexo Theme by Aath点击Theme by 后面的连接，一般会简介到本主题在GitHub上的仓库地址。 根据说明，下载配置主题。 下载主题。比如：12# 切换到MyBlog文件下，cmd执行git clone -b master https://github.com/lewis-geek/hexo-theme-Aath.git themes/aath 一般，它会自动下载到themes文件夹下。 跟换博客的主题：下载好后，你在_config.yml（主题是MyBlog文件夹下的）中的theme：处配置成你下在的主题名字（就是下载的主题文件夹名字 ） 配置主题：根据GitHub上的说明配置themes/主题名目录下的_config.yml（不要与MyBlog的_config.yml搞混）。不同主题，配置起来不一样，所以在此不详解了。 发布到GitHub Github上新建仓库：打开GitHub网页，点击头像旁边的“+”号 -&gt; New repository -&gt; 填写名字（必须是：你GitHub的名字.github.io） 本地配置Git：在MyBlog文件夹下的_config.yml配置（大约在底部位置）： 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/wzmyyj/wzmyyj.github.io.git branch: master 上传： 123456# 如果想把原来的清除hexo clean# 重新生成静态文件hexo g# 上传到提交文件hexo d 第一次提交需要GitHub登录账号和密码。 上传完成后，浏览器打开：https://你的GitHub名字.github.io 就是你的博客主页地址了。（GitHub响应比较慢，刚上传需要等一小会才能打开最新的。） 写文章 新建一篇文章：12# 新建hexo new post 文章名 在Myblog\\source\\_posts目录下你将看到一个新建的文章名.md文件。 编辑文章：用editplus打开编辑，用Markdown格式书写。 保存时，记得把编码方式改成utf-8。Document -&gt; File Encoding -&gt; Convert Encoding… 建议用简书写（简书设置里把编辑器改成Markdown），然后复制过去。好处是图片存在简书上，访问起来快些。 上传：（和前面一样）12345678# 如果想把原来的清除hexo clean# 重新生成静态文件hexo g# 本地测试hexo s# 上传到提交文件hexo d 到此，你的博客主页已经完成。 跟换域名 购买一个域名。（阿里云，腾讯云，万网均可注册购买域名） 修改你域名的DNS地址为 dns22.hichina.com, dns21.hichina.com 域名解析上，CNAME到你的GitHub名字.github.io 然后在你的本地站点目录里的source目录下添加一个CNAME文件。以文本编辑器打开CNAME，里面添加你的域名（不加http://）。 在MyBlog文件夹下的_config.yml配置url： 1234# URL## If your site is put in a subdirectory, ## set url as 'http://yoursite.com/child' and root as '/child/'url: http://wzmyyj.top //你的域名 重新生成静态文件和上传到GitHub。 附件1. 参考文献：Hexo环境搭建2018年5月版搭建个人博客-hexo+github详细完整步骤我的博客是如何搭建的（github pages + HEXO + 域名绑定）Hexo中文文档 2. 我的主页： 欢迎大家浏览我的主页：http://wzmyyj.top/","tags":[{"name":"IT","slug":"IT","permalink":"https://wzmyyj.top/tags/IT/"}]},{"title":"《提问的智慧》","date":"2018-06-04T12:08:19.000Z","path":"2018/06/04/it_3/","text":"提问的智慧艾瑞克.史蒂文.雷蒙德（Eric Steven Raymond）Thyrsus Enterprises &#101;&#x73;&#x72;&#64;&#116;&#104;&#x79;&#114;&#115;&#x75;&#x73;&#x2e;&#x63;&#111;&#x6d;瑞克.莫恩（Rick Moen） &#114;&#101;&#x73;&#112;&#111;&#110;&#x64;&#45;&#97;&#x75;&#x74;&#x6f;&#x40;&#108;&#x69;&#x6e;&#x75;&#x78;&#109;&#97;&#x66;&#x69;&#x61;&#46;&#99;&#x6f;&#x6d;版权©2001, 2006 Eric S. Raymond, Rick Moen 传送门中文：《提问的智慧》 原文：《How To Ask Questions The Smart Way》 要求声明：（我们不提供该项目的服务支持！）","tags":[{"name":"IT","slug":"IT","permalink":"https://wzmyyj.top/tags/IT/"}]},{"title":"仅仅是几张图而已哦^_^","date":"2018-06-01T13:20:06.000Z","path":"2018/06/01/pic_1/","text":"仅仅是几张图而已哦^_^。。。啦啦啦啦啦。。。。","tags":[{"name":"图片","slug":"图片","permalink":"https://wzmyyj.top/tags/图片/"}]},{"title":"Android日志工具Log类","date":"2018-05-22T12:43:30.000Z","path":"2018/05/22/android_1/","text":"android.util.Log类android.util.Log常用的方法有以下5个：Log.v()， Log.d() ，Log.i() ，Log.w() 以及 Log.e() 。根据首字母对应VERBOSE，DEBUG，INFO， WARN，ERROR。 Log.v 的输出颜色为黑色的，任何消息都会输出，这里的v代表verbose啰嗦的意思。 Log.d的输出颜色为蓝色的，仅输出debug调试的意思，但他会输出上层的信息，过滤起来可以通过DDMS的Logcat标签来选择。 Log.i的输出颜色为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息。 Log.w的输出颜色为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。 Log.e的输出颜色为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。 1,常规用法12345Log.v(TAG,\"一条啰嗦日志\");Log.d(TAG,\"一条调试日志\");Log.i(TAG,\"一条提示日志\");Log.w(TAG,\"一条警告日志\");Log.e(TAG,\"一条错误日志\"); 其中TAG为字符串。用于标记。同一个应用TAG基本可以成一样。并且，应用打包发布时，最好把全部Log注释掉，否则将产生不必要的资源消耗（虽然很小）。 2,分装Log123456789101112131415161718192021222324252627282930313233343536373839404142public class L &#123; private static String TAG = \"WZM\"; // 开关 private static boolean debug = true; private L() &#123; &#125; public static void setTAG(String TAG) &#123; L.TAG = TAG; &#125; public static void setDebug(boolean debug) &#123; L.debug = debug; &#125; public static void v(String msg) &#123; if (debug) Log.v(TAG, msg); &#125; public static void d(String msg) &#123; if (debug) Log.d(TAG, msg); &#125; public static void i(String msg) &#123; if (debug) Log.i(TAG, msg); &#125; public static void w(String msg) &#123; if (debug) Log.w(TAG, msg); &#125; public static void e(String msg) &#123; if (debug) Log.e(TAG, msg); &#125;&#125; 使用时：12345L.v(\"一条啰嗦日志\");L.d(\"一条调试日志\");L.i(\"一条提示日志\");L.w(\"一条警告日志\");L.e(\"一条错误日志\"); 并且，可在Application中设置开关（是否输出日志）或TAG（默认WZM）12345678public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); L.setTAG(\"TAG\"); L.setDebug(false); &#125;&#125; 打包发布时，debug设为false即可。 其他还有对Toast的简单封装：Android 封装Toast","tags":[{"name":"android","slug":"android","permalink":"https://wzmyyj.top/tags/android/"}]},{"title":"【设计模式】抽象工厂模式","date":"2018-05-19T09:50:00.000Z","path":"2018/05/19/design_4/","text":"工厂模式 抽象工厂模式（Abstract Factory Pattern）是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。 如果读者不了解工厂模式，请看上篇【设计模式】工厂模式。 UML类图 抽象产品类（AbstractProductX）：多个系列抽象产品（X=A,B,C…）。 具体产品类（ProductX）：实现基类中的抽象方法（多个不同的具体产品，X=1,2,3..）。 抽象工厂类或接口（AbstractFactory）：定义具体工厂的多个公共接口（拥有各系列产品创建的接口）。 具体工厂类（FactoryX）：定义创建各系列具体产品实例的方法。（每个工厂对应一种具体产品，X=1,2,3…）。 与工厂模式的区别 工厂模式的工厂只能生产一个系列的产品。而抽象工厂模式的工厂可以生产一个或多个系列的产品。 工厂模式关注的是一个系列的不同种产品。而抽象工厂模式关注的是不同系列产品。 案例分析接着上篇【设计模式】工厂模式的话题。 场景：玩《英雄联盟》（5v5 moba端游）新开一局游戏，游戏开始每个玩家需要选一个英雄之外，还需要选择天赋，召唤师技能。也就是需要创建三种产品。并且，在不同玩法下，比如召唤师峡谷（自选或排位等）与哭嚎深渊（大乱斗），创建的产品也略微有所差异，比如大乱斗下英雄一开始就3级，召唤师技能没有传送，有雪球。结构上： 产品（三个系列）：英雄，天赋，召唤师技能。 工厂（两个）：召唤师峡谷工厂，哭嚎深渊工厂。 代码实现英雄基类（新增lv成员变量和print()方法）123456789101112public abstract class Hero &#123; protected String name; protected int lv; public abstract void say(); public void print() &#123; System.out.println(\"name:\" + name); System.out.println(\"lv:\" + lv); &#125;&#125; 只考虑一种英雄，比如寒冰射手-艾希。 艾希类：123456789101112public class Ashe extends Hero &#123; // 简化构造方法，只弄个名字。 public Ashe() &#123; this.name = \"寒冰射手-艾希\"; &#125; // 艾希台词（不重要） @Override public void say() &#123; System.out.println(name + \"：\" + \"世间万物皆系于一箭之上。\"); &#125;&#125; 召唤师峡谷中的艾希：1234567public class Ashe_XiaGu extends Ashe &#123; // 在召唤师峡谷中初始等级1级。 public Ashe_XiaGu() &#123; super(); this.lv = 1; &#125;&#125; 哭嚎深渊中的艾希：1234567public class Ashe_ShenYuan extends Ashe &#123; // 在哭嚎深渊中初始等级3级。 public Ashe_ShenYuan() &#123; super(); this.lv = 3; &#125;&#125; 天赋基类：（就简单点只用打印信息区分下好了）1234public abstract class Talent &#123; // 只打印一下信息 public abstract void print();&#125; 两个天赋实现类：12345678public class Talent_XiaGu extends Talent&#123; @Override public void print() &#123; System.out.println(\"召唤师峡谷中的天赋\"); &#125;&#125; 12345678public class Talent_ShenYuan extends Talent&#123; @Override public void print() &#123; System.out.println(\"哭嚎深渊中的天赋\"); &#125;&#125; 召唤师技能基类：123456789public abstract class Skill &#123; // 召唤师技能种类 protected String[] skill_type; // 选择两种召唤师技能 public void choose(int i, int j) &#123; System.out.println(\"你选择了\" + skill_type[i] + \"和\" + skill_type[j]); &#125;&#125; 两个召唤师技能实现类：123456public class Skill_XiaGu extends Skill &#123; public Skill_XiaGu() &#123; this.skill_type = new String[] &#123; \"闪现\", \"治疗\", \"传送\", \"净化\", \"光盾\", \"虛弱\", \"惩戒\", \"疾走\" &#125;; &#125;&#125; 123456public class Skill_ShenYuan extends Skill &#123; public Skill_ShenYuan() &#123; this.skill_type = new String[] &#123; \"闪现\", \"治疗\", \"雪球\", \"净化\", \"光盾\", \"虛弱\", \"回蓝\", \"疾走\" &#125;; &#125;&#125; 准备工作完毕，接下来就是重点了。 抽象工厂类或接口：123456789public interface AbstractFactory &#123; //创建英雄 public abstract Hero createHero(); //创建天赋 public abstract Talent createTalent(); //创建召唤师技能 public abstract Skill createSkill();&#125; 召唤师峡谷工厂类：1234567891011121314public class Factory_XiaGu implements AbstractFactory &#123; //假设我选艾希 public Hero createHero() &#123; return new Ashe_XiaGu(); &#125; public Talent createTalent() &#123; return new Talent_XiaGu(); &#125; public Skill createSkill() &#123; return new Skill_XiaGu(); &#125;&#125; 哭嚎深渊工厂类：1234567891011121314public class Factory_ShenYuan implements AbstractFactory &#123; //假设我选艾希 public Hero createHero() &#123; return new Ashe_ShenYuan(); &#125; public Talent createTalent() &#123; return new Talent_ShenYuan(); &#125; public Skill createSkill() &#123; return new Skill_ShenYuan(); &#125;&#125; 最后是客户端代码：1234567891011121314151617181920212223242526272829303132public class Client &#123; public static void main(String[] args) &#123; System.out.println(\"请选择游戏模式\"); System.out.println(\"1,召唤师峡谷 2,哭嚎深渊\"); Scanner can = new Scanner(System.in); int w = can.nextInt(); can.close(); AbstractFactory factory = null; switch (w) &#123; case 1: // 召唤师峡谷 factory = new Factory_XiaGu(); break; case 2: // 哭嚎深渊 factory = new Factory_ShenYuan(); break; &#125; // 英雄（选择的是艾希） Hero hero = factory.createHero(); hero.print(); hero.say(); // 天赋 Talent talent = factory.createTalent(); talent.print(); // 召唤师技能 Skill skill = factory.createSkill(); skill.choose(0, 2); &#125;&#125; 客户端选择游戏模式，就相当于选择了不同的工厂去生产游戏元素（英雄，天赋，召唤师技能）。 也可以结合工厂模式使用，比如选择游戏类型后，利用工厂模式选择英雄等等。 同工厂模式，客户端不需要知道产品的创建过程。并且，客户端只需要选择游戏模式，就可以用工厂创建多个系列的产品（英雄，天赋，召唤师技能）。主要特点就是一个工厂多系列产品。 运行结果玩局匹配，选召唤师峡谷： 源计划皮肤的寒冰射手。 实际应用常见的案例就是使用不同的数据库，数据库能处理用户，也能处理关系。但是，数据库分MySQL，Orical等。处理同样或类似的事情，他们的具体实现存在差异。那就可以抽出一个工厂基类，再分别写两个不同的工厂去处理。这样的话，某些东西就可以做到可迁移的目的。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wzmyyj.top/tags/设计模式/"}]},{"title":"【设计模式】工厂模式","date":"2018-05-18T09:52:10.000Z","path":"2018/05/18/design_3/","text":"工厂模式工厂模式（Factory Pattern）就是专门负责将大量有共同接口的类实例化，而且不必事先知道每次是要实例化哪一个类的模式。它定义一个用于创建对象的接口，由子类决定实例化哪一个类。工厂模式相当于创建实例对象的new，经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的。 UML类图 抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。 具体产品类（ProductX）：实现基类中的抽象方法（多个不同的具体产品，X=1,2,3..）。 抽象工厂类或接口（AbstractFactory）：定义具体工厂的公共接口。 具体工厂类（FactoryX）：定义创建对应具体产品实例的方法。（每个工厂对应一种具体产品，X=1,2,3…）。 案例分析既然是工厂，当然是要生产产品。那我们来造什么好呢？，，嗯，，，造小孩？NO，NO，NO！我们还是来造英雄吧。 场景：玩《英雄联盟》（5v5 moba端游）新开一局游戏，游戏开始每个玩家需要选一个信赖的英雄。选好后，英雄会很兴奋，说一句专属的台词。那么程序上是new出该英雄的对象，执行该对象的say()方法。 常规写法：建立英雄类：123456public abstract class Hero &#123; protected String name; public abstract void say();&#125; 寒冰射手-艾希类（继承Hero类）：12345678910111213public class Ashe extends Hero &#123; // 简化构造方法，只弄个名字。 public Ashe() &#123; this.name = \"寒冰射手-艾希\"; &#125; // 艾希台词 @Override public void say() &#123; System.out.println(name + \"：\" + \"世间万物皆系于一箭之上。\"); &#125;&#125; 类似的写了亚索类，光辉类，盖伦类，剑圣类（全部英雄的话，还有好多）。再写个枚举（可以不需要，仅仅拿来当对应标识使用）。1234567public enum Who &#123; Ashe, Garen, Yi, Lux, Yasuo&#125; 然后客户端调用：（菜鸟写法）1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Client1 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 Ashe ashe = new Ashe(); ashe.say(); break; case Yasuo: // 亚索 Yasuo yasuo = new Yasuo(); yasuo.say(); break; case Garen: // 德玛 Garen garen = new Garen(); garen.say(); break; case Lux: // 光辉 Lux lux = new Lux(); lux.say(); break; case Yi: // 剑圣 Yi yi = new Yi(); yi.say(); break; &#125; &#125;&#125; 客户端调用：（好学生写法，父类的子类引用）123456789101112131415161718192021222324252627282930313233public class Client2 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); Hero hero = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 hero = new Ashe(); break; case Yasuo: // 亚索 hero = new Yasuo(); break; case Garen: // 德玛 hero = new Garen(); break; case Lux: // 光辉 hero = new Lux(); break; case Yi: // 剑圣 hero = new Yi(); break; &#125; hero.say(); &#125;&#125; 这里客户端需要知道： 英雄怎么构造，怎么new出来。（事实上英雄的构造远没有这么简单。） 每个英雄的方法怎么调用。（这里都是say()方法） 我们前面提到，利用工厂可以把创建对象的过程封装掉，客户端只要知道得到对象后调用其方法即可。用工厂代替new的过程。那就看看工厂方法怎么去实现吧。 ####工厂模式写法先建立一个工厂类的接口：1234public interface Factory &#123; //创建英雄的接口 public abstract Hero create();&#125; 然后建立不同英雄对应的工厂实现类。比如艾希工厂：123456public class AsheFactory implements Factory &#123; //实现具体的创建英雄的方法。 public Hero create() &#123; return new Ashe(); &#125;&#125; 同样的建立亚索工厂，光辉工厂，盖伦工厂，剑圣工厂等。 然后客户端调用：12345678910111213141516171819202122232425262728293031323334public class Client3 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); Factory factory = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希工厂 factory = new AsheFactory(); break; case Yasuo: // 亚索工厂 factory = new YasuoFactory(); break; case Garen: // 德玛工厂 factory = new GarenFactory(); break; case Lux: // 光辉工厂 factory = new LuxFactory(); break; case Yi: // 剑圣工厂 factory = new YiFactory(); break; &#125; Hero hero = factory.create(); hero.say(); &#125;&#125; switch中不再是英雄的创建过程，而是选择英雄工厂的过程。根据不同name选择不同的工厂，然后由工厂去实例化具体英雄对象。 新增一个英雄，就新增一个对应的工厂。需要修改的只有客户端代码。 如果不需要新增也不需要减少。我们是不是可以把工厂的选择封装起来。让多家工厂合并成一家工厂。那就是接下来要讲的简单工厂模式 简单工厂模式 简单工厂模式（Simple Factory Pattern）是类的创建模式，又叫做静态工厂方法模式。就是由一个工厂类根据传入的参量决定创建出哪一种产品类的实例。与上面工厂模式的区别就是它只需要一个工厂。 UML类图 抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。 具体产品类（ConcreteProduct）：实现基类中的抽象方法。 工厂类（Factory）：用以封装实例化对象过程，根据传入的参数决定生产不同的产品。 利用简单工厂的写法：其他地方不变，将工厂合并成一个工厂类，并在内部写个静态方法，根据传入的参数决定创建不同的英雄对象：12345678910111213141516171819202122232425262728293031public class SimpleFactory &#123; public static Hero create(String name) &#123; Hero hero = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 hero = new Ashe(); break; case Yasuo: // 亚索 hero = new Yasuo(); break; case Garen: // 德玛 hero = new Garen(); break; case Lux: // 光辉 hero = new Lux(); break; case Yi: // 剑圣 hero= new Yi(); break; &#125; return hero; &#125;&#125; 客户端代码做简单修改：12345678910public class Client4 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); // 根据传入的名字构建不同的英雄。 Hero hero = SimpleFactory.create(name); hero.say(); &#125;&#125; 客户端不需要知道对象的构建过程，只要传入参数得到不同对象。 但是简单工厂是固定的，如果增减英雄他就要修改。不符合开闭原则。这时候用前面工厂模式好，把修改转移给客户端，而不修改工厂代码。 运行结果选个盖伦试试： 不浪了，不浪了。 抽象工厂模式请看下篇【设计模式】抽象工厂模式。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wzmyyj.top/tags/设计模式/"}]},{"title":"【设计模式】单例模式","date":"2018-04-17T13:20:06.000Z","path":"2018/04/17/design_2/","text":"单例模式单例模式（Singleton Pattern）是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。 某个类只能有一个实例。 它必须自行创建这个实例。 它必须自行向整个系统提供这个实例。 单例模式关键点： 构造函数私有化（不让外部创建此类对象）。 通过一个静态方法或枚举返回单例类对象。 多线程环境下，确保单例（难点）。 反序列化不会重新构建对象。 饿汉式12345678910111213141516171819public class Singleton &#123; // 单例对象 private final static Singleton INSTANCE = new Singleton(); // 或 // private final static Singleton INSTANCE; // static &#123; // INSTANCE = new Singleton(); // &#125; // 私有构造方法 private Singleton() &#123; &#125; // 公有静态方法用于获取单例对象 public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 线程安全。但是没使用它时，就已经建立了对象，开销内存。 懒汉式12345678910111213141516public class Singleton &#123; // 单例对象 private static Singleton INSTANCE = null; // 私有构造方法 private Singleton() &#123; &#125; // synchronized关键字修饰静态方法 public static synchronized Singleton getInstance() &#123; if (null == INSTANCE) &#123;// 空值判断 INSTANCE = new Singleton(); &#125; return INSTANCE; &#125;&#125; 在第一次调用getInstance()时，创建单例对象。synchronized关键字修饰，使getInstance()是一个同步方法。保证多线程情况下单例对象的唯一。但是，同步会耗费资源。 双检锁式（Double Check Lock（DCL））1234567891011121314151617181920public class Singleton &#123; // 单例对象，volatile关键字保证INSTANCE的原子性 private volatile static Singleton INSTANCE = null; // 私有构造方法 private Singleton() &#123; &#125; // 两次空值检查，synchronized关键字同步 public static Singleton getInstance() &#123; if (null == INSTANCE) &#123; synchronized (Singleton.class) &#123; if (null == INSTANCE) &#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 语句INSTANCE = new Singleton();在编译时的步骤如下： 给Singleton的实例分配内存。 调用Singleton()的构造函数，初始化成员字段。 将INSTANCE 对象指向分配的内存空间（此时对象非空）。 Java编译器允许处理器乱序执行。上诉的2，3两步的顺序可能被打乱。打乱后，非空判断的线程不安全。在JDK1.5之后，调整了JVM，具体化了volatile关键字，表示此操作是一个原子操作，不能中间被分割执行。使用volatile关键字会影响性能。 静态内部类123456789101112131415public class Singleton &#123; // 内部类，包含单例的对象 private static class SingletonHolder &#123; public static final Singleton INSTANCE = new Singleton(); &#125; // 私有构造方法 private Singleton() &#123; &#125; // 公有静态方法用于获取单例对象 public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 第一次加载Singleton时，SingletonHolder不会被加载。只用调用getInstance()时，才加载SingletonHolder，并创建INSTANCE。推荐大家使用。 枚举式123public enum SingletonEnum &#123; INSTANCE;&#125; 虽说代码简单，enum的实质也是class（编译时，会先翻译成一个class）。优点是反序列化也不会重新生成新的实例。 前几种方式，如果要避免反序列化也不会重新生成新的实例。需要重写：123private Object readResolve() throws ObjectStreamException&#123; return INSTANCE;&#125; 单例管理类一个程序可能有多个单例对象。先建立一个上诉管理类。1234567891011121314151617181920public class SingletonManager &#123; // 容器 private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String, Object&gt;(); // 私有构造方法 private SingletonManager() &#123; &#125; // 注册单例 public static void ascendSingleton(String key, Object instance) &#123; if (!objMap.containsKey(key)) &#123; objMap.put(key, instance); &#125; &#125; // 获得单例对象 public static Object getInstance(String key) &#123; return objMap.get(key); &#125;&#125; 通过注册，可以管理多种类型的单例，使用统一接口，隐藏具体实现。使用时：12//注册单例SingletonManager.ascendSingleton(\"SingletonKey\",Singleton.getInstance()); 12//获得单例对象Singleton singleton = SingletonManager.getInstance(\"SingletonKey\"); 优点 只有一个对象，全局使用。 只需要建立一次，占一个内存，节约资源。 缺点 没有接口，难以扩展。 生命周期长，如果引用短生命周期对象会内存泄漏。 补充通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wzmyyj.top/tags/设计模式/"}]},{"title":"【设计模式】面向对象六大原则","date":"2018-04-14T16:08:04.000Z","path":"2018/04/15/design_1/","text":"设计模式设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化。设计模式分为三种类型，分别是：创建型模式、结构型模式，行为型模式。 23种设计模式 创建型模式，共5种：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 六大原则1，单一职责原则（Single Responsibility Principle, SRP）定义：一个类应只包含单一的职责。 如果一个类职责过多，代码量就多，而使用起来显得过分冗余，不利于复用。 如果修改某个职责，可能影响另一个职责。 2，开放封闭原则(Open - ClosedPrinciple ,OCP)定义：一个模块、类、函数应当是对修改关闭，对扩展开放。 修改原有的代码可能会导致原本正常的功能出现问题。 当需求改变时，最好通过扩展来实现，增加新的方法或类满足需求，而不是去修改原有代码。 3，里氏代换原则( Liskov Substitution Principle ,LSP )定义：使用父类的地方能够使用子类来替换，反过来，则不行。 使用子类对象去替换父类对象，程序将不会产生错误。 程序中尽量使用基类类型来对对象进行定义，如父类的子类引用，而在运行时再确定其子类类型，用子类对象来替换父类对象。 4，依赖倒转原则( Dependence Inversion Principle ,DIP )定义：抽象不应该依赖于细节，细节应当依赖于抽象。 即要面向接口编程，而不是面向具体实现去编程。 高层模块不应该依赖低层模块，应该去依赖抽象。 方法定义时，传入对象用抽象类型，实际使用时传入子类对象。 5，接口隔离法则(Interface Segregation Principle，ISL）定义：一个类对另一个类的依赖应该建立在最小的接口上。 一个类不应该依赖他不需要的接口，接口的方法全要用得到。 接口粒度要尽可能小，尽量不能再分割。一个接口的方法过多，可以拆成多个接口。 6，迪米特法则(Law of Demeter, LoD)定义：一个类尽量不要与其他类发生关系 一个类对其他类知道的越少越好，耦合越小。导入的东西越少越好。 当修改一个类时，其他类的影响就越小，发生错误的可能性就越小。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wzmyyj.top/tags/设计模式/"}]},{"title":"【算法】归并排序","date":"2018-04-14T13:35:08.000Z","path":"2018/04/14/java_1/","text":"归并排序归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序算法稳定，数组需要O(n)的额外空间，链表需要O(log(n))的额外空间，时间复杂度为O(nlog(n))，算法不是自适应的，不需要对数据的随机读取。 工作原理 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。 设定两个指针，最初位置分别为两个已经排序序列的起始位置。 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。 重复步骤3直到某一指针达到序列尾。 将另一序列剩下的所有元素直接复制到合并序列尾。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class MergeSortTest &#123; public static void main(String[] args) &#123; //测试数据 int A[] = &#123; 1, 6, 4, 5, 2, 9, 7, 23, 56, 43, 99 &#125;; // 排序前 System.out.println(\"排序前：\"); for (int a : A) &#123; System.out.print(a + \" \"); &#125; System.out.println(); // 排序 mergeSort(A); // 排序后 System.out.println(\"排序后：\"); for (int a : A) &#123; System.out.print(a + \" \"); &#125; System.out.println(); &#125; // 排序入口 public static void mergeSort(int[] A) &#123; sort(A, 0, A.length - 1); &#125; //递归 public static void sort(int[] A, int start, int end) &#123; if (start &gt;= end) return; // 找出中间索引 int mid = (start + end) / 2; // 对左边数组进行递归 sort(A, start, mid); // 对右边数组进行递归 sort(A, mid + 1, end); // 合并 merge(A, start, mid, end); &#125; // 将两个数组进行归并，归并前面2个数组已有序，归并后依然有序 public static void merge(int[] A, int start, int mid, int end) &#123; int[] temp = new int[A.length];// 临时数组 int k = 0; int i = start; int j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; // 从两个数组中取出较小的放入临时数组 if (A[i] &lt;= A[j]) &#123; temp[k++] = A[i++]; &#125; else &#123; temp[k++] = A[j++]; &#125; &#125; // 剩余部分依次放入临时数组（实际上两个while只会执行其中一个） while (i &lt;= mid) &#123; temp[k++] = A[i++]; &#125; while (j &lt;= end) &#123; temp[k++] = A[j++]; &#125; // 将临时数组中的内容拷贝回原数组中 （left-right范围的内容） for (int m = 0; m &lt; k; m++) &#123; A[m + start] = temp[m]; &#125; &#125;&#125; 对于算法，理解原理很重要。。。 附页GitHub源码：https://github.com/wzmyyj/MergeSort","tags":[{"name":"java","slug":"java","permalink":"https://wzmyyj.top/tags/java/"}]},{"title":"L2TP/IPSec配置教程","date":"2018-04-10T13:40:49.000Z","path":"2018/04/10/it_2/","text":"L2TP/IPSecL2TP是一种工业标准的Internet隧道协议，功能大致和PPTP协议类似，比如同样可以对网络数据流进行加密。不过也有不同之处，比如PPTP要求网络为IP网络，L2TP要求面向数据包的点对点连接；PPTP使用单一隧道，L2TP使用多隧道；L2TP提供包头压缩、隧道验证，而PPTP不支持。 服务器首先，需要一个服务器。我采用的是Vultr服务器。 配置服务器端我们采用的是Github上setup-ipsec-vpn这个脚本安装方法，不需要特别配置，简单安装。 1, Ubuntu &amp; Debian：1, 远程连接到上诉买的服务器。（默认的用户名是root） 1ssh root@服务器ip地址 这里，下一步会让你输入密码。复制粘贴（右键粘贴，不能Ctrl+v）即可。（控制台上不会显示出密码，粘贴后直接回车即可） 等待连接完成。 2, 刷新一下。复制粘贴下行代码。1sudo apt-get update 3, 安装脚本。复制粘贴下行代码。 1wget https://git.io/vpnsetup -O vpnsetup.sh &amp;&amp; sudo sh vpnsetup.sh 等待安装完成，需要点点时间。 安装好后，会自动分配 Username，Password，Pre-Shared key（一些参数，默认是一些随机数。） 4, 修改参数。 123456#所有变量值必须用 '单引号' 括起来#*不要* 在值中使用这些字符： \\ \" ' wget https://git.io/vpnsetup -O vpnsetup.sh&amp;&amp;sudo \\VPN_IPSEC_PSK='你的IPsec预共享密钥'\\VPN_USER='你的VPN用户名'\\VPN_PASSWORD='你的VPN密码' sh vpnsetup.sh 2, CentOS &amp; RHEL：首先，更新你的系统。第一步改成：1yum update 重启。这一步是可选的，但推荐。 按照与上面相同的步骤，但是 将 https://git.io/vpnsetup 换成 https://git.io/vpnsetup-centos。 到此，你的L2TP/IPSec类型VPN配置完成。 配置客户端1, 安卓手机设置–&gt;连接–&gt;VPN连接–&gt;添加连接–&gt;名称随便取–&gt;类型选L2TP/IPSec PSK–&gt;输入IP地址，预用共享密钥（不是L2TP密钥，未使用的不要填），用户名，密码–&gt;连接（如果第一次连接失败，重试可能仍失败，建议删除连接，重新配置）。 2, Windows电脑打开网络共享中心–&gt;设置新的连接或网络–&gt;连接到工作区–&gt;创建新的连接–&gt;使用我的Internet连接–&gt;填写地址和名称–&gt;填写用户名和密码（域不要填）–&gt;保存连接（不要立刻连接）–&gt;电脑上出现新的连接–&gt;右键–&gt;属性–&gt;安全–&gt;VPN类型（选L2TP/IPSec）–&gt;高级设置–&gt;填写密钥–&gt;保存，连接。 （不同win版本会有所不同。） 3, 其他百度一下，你就知道。 作用学习使人快乐！","tags":[{"name":"IT","slug":"IT","permalink":"https://wzmyyj.top/tags/IT/"}]},{"title":"一起来整个服务器玩玩","date":"2018-04-07T08:11:50.000Z","path":"2018/04/07/it_1/","text":"服务器Vultr是一家服务器厂商,这个VPS服务商是按小时收费的。这意味着,架设一台VPS的成本较低。 ##购买步骤 1, 登录官网：https://www.vultr.com/。注册一个自己的账号。 2, 确定需要的服务器配置。一般而言，我们只需要最低配置选择$2.5/月（大约15元/月）的即可。（好多可能售完，只有Miami还有$2.5的）。系统选择推荐Ubuntu （16.04或14.04）。 2.1, 地点 2.2, 系统 2.3, 附加服务 2.4, 主机名 3, 支付。选择支付宝扫码支付。至少支付$10（60多元）。 4, 购买步骤2选的服务器。 到此。你的服务器购买完毕。 管理Vultr服务器1, 服务器管理界面。 重点看ID，用户名和密码，连接服务必须。","tags":[{"name":"IT","slug":"IT","permalink":"https://wzmyyj.top/tags/IT/"}]}]