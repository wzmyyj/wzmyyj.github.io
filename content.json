[{"title":"【android】四种引用比较与源码分析","date":"2018-06-09T06:40:41.000Z","path":"2018/06/09/android_3/","text":"Android四种引用比较与源码分析 【转】：https://blog.csdn.net/m0_37700275/article/details/79820814（版权归原作者所有） 0.关于四种引用0.1 引用说明 java.lang.ref包中提供了几个类：SoftReference类、WeakReference类和PhantomReference类，它们分别代表软引用、弱引用和虚引用。ReferenceQueue类表示引用队列，它可以和这三种引用类联合使用，以便跟踪Java虚拟机回收所引用的对象的活动。 0.2 关于Java下ref包和Android下ref包 在Android下的ref包结构 在java下的ref包 1.强引用1.0 关于强引用引用的场景 直接new出来的对象 String str = new String(“yc”); 1.1 强引用介绍 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 通过引用，可以对堆中的对象进行操作。在某个函数中，当创建了一个对象，该对象被分配在堆中，通过这个对象的引用才能对这个对象进行操作。 1.2 强引用的特点 强引用可以直接访问目标对象。 强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。 强引用可能导致内存泄露。 1.3 注意相互引用情况2.软引用2.0 关于SoftReference软引用 SoftReference：软引用–&gt;当虚拟机内存不足时，将会回收它指向的对象；需要获取对象时，可以调用get方法。 可以通过java.lang.ref.SoftReference使用软引用。一个持有软引用的对象，不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。当堆的使用率临近阈值时，才会回收软引用的对象。 2.1 软引用应用场景 例如从网络上获取图片，然后将获取的图片显示的同时，通过软引用缓存起来。当下次再去网络上获取图片时，首先会检查要获取的图片缓存中是否存在，若存在，直接取出来，不需要再去网络上获取。 2.2 软引用的简单使用 用法如下 123MyObject aRef = new MyObject();SoftReference aSoftRef = new SoftReference(aRef);MyObject anotherRef = (MyObject)aSoftRef.get(); 2.3 软引用的特点 2.3.1 特点： 如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 2.3.2 代码如下 12ReferenceQueue queue = new ReferenceQueue();SoftReference ref = new SoftReference(aMyObject, queue); 2.3.3 如何回收： 那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。 在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。 常用的方式为 1234SoftReference ref = null;while ((ref = (EmployeeRef) q.poll()) != null) &#123; // 清除ref&#125; 2.4 实际应用案例 2.4.1 正常是用来处理图片这种占用内存大的情况 代码如下所示 1234567View view = findViewById(R.id.button);Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher);Drawable drawable = new BitmapDrawable(bitmap);SoftReference&lt;Drawable&gt; drawableSoftReference = new SoftReference&lt;Drawable&gt;(drawable);if(drawableSoftReference != null) &#123; view.setBackground(drawableSoftReference.get());&#125; 2.4.2 这样使用软引用好处 通过软引用的get()方法，取得drawable对象实例的强引用，发现对象被未回收。在GC在内存充足的情况下，不会回收软引用对象。此时view的背景显示 实际情况中,我们会获取很多图片.然后可能给很多个view展示, 这种情况下很容易内存吃紧导致oom,内存吃紧，系统开始会GC。这次GC后，drawables.get()不再返回Drawable对象，而是返回null，这时屏幕上背景图不显示，说明在系统内存紧张的情况下，软引用被回收。 使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。 2.5 注意避免软引用获取对象为null 在垃圾回收器对这个Java对象回收前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该Java对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。 3.弱引用3.0 关于WeakReference弱引用 3.0.1 WeakReference 弱引用–&gt;随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收。要获取对象时，同样可以调用get方法。 3.0.2 特点 如果一个对象只具有弱引用，那么在垃圾回收器线程扫描的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用也可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 3.1 WeakReference：防止内存泄漏，要保证内存被虚拟机回收 3.1.1 先看一个handler小案例【千万不要忽视淡黄色警告】 3.1.2 为什么这样会造成内存泄漏 这种情况就是由于android的特殊机制造成的：当一个android主线程被创建的时候，同时会有一个Looper对象被创建，而这个Looper对象会实现一个MessageQueue(消息队列)，当我们创建一个handler对象时，而handler的作用就是放入和取出消息从这个消息队列中，每当我们通过handler将一个msg放入消息队列时，这个msg就会持有一个handler对象的引用。因此当Activity被结束后，这个msg在被取出来之前，这msg会继续存活，但是这个msg持有handler的引用，而handler在Activity中创建，会持有Activity的引用，因而当Activity结束后，Activity对象并不能够被gc回收，因而出现内存泄漏。 3.1.3 根本原因 Activity在被结束之后，MessageQueue并不会随之被结束，如果这个消息队列中存在msg，则导致持有handler的引用，但是又由于Activity被结束了，msg无法被处理，从而导致永久持有handler对象，handler永久持有Activity对象，于是发生内存泄漏。但是为什么为static类型就会解决这个问题呢？因为在java中所有非静态的对象都会持有当前类的强引用，而静态对象则只会持有当前类的弱引用。声明为静态后，handler将会持有一个Activity的弱引用，而弱引用会很容易被gc回收，这样就能解决Activity结束后，gc却无法回收的情况。 3.2 弱引用解决办法 代码如下所示 1234567891011121314private MyHandler handler = new MyHandler(this);private static class MyHandler extends Handler&#123; WeakReference&lt;FirstActivity&gt; weakReference; MyHandler(FirstActivity activity) &#123; weakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what)&#123; &#125; &#125;&#125; 3.3 弱引用实际应用案例 具体案例可以参考我的代码：https://github.com/yangchong211/YCVideoPlayer 4.虚引用4.0 关于PhantomReference类虚引用 虚引用是所有引用类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，奖这个虚引用加入引用队列。 4.1 Android实际开发中没有用到过 貌似开发中没有接触过虚引用 5.四种引用其他介绍5.1 弱引用和软引用区别 弱引用与软引用的根本区别在于：只具有弱引用的对象拥有更短暂的生命周期，可能随时被回收。而只具有软引用的对象只有当内存不够的时候才被回收，在内存足够的时候，通常不被回收。 5.2 使用软引用或者弱引用防止内存泄漏 在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。 软引用，弱引用都非常适合来保存那些可有可无的缓存数据。如果这样做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间。 5.3 到底什么时候使用软引用，什么时候使用弱引用呢？ 个人认为，如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 还有就是可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。 另外，和弱引用功能类似的是WeakHashMap。WeakHashMap对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的回收，回收以后，其条目从映射中有效地移除。WeakHashMap使用ReferenceQueue实现的这种机制。 5.4 四种引用用一张表总结[摘自网络] 6.源码分析6.1 首先看看如何通过弱引用加载图片 6.2 看看Reference的源代码 6.2.1 源码说明： 看到Reference除了带有对象引用referent的构造函数，还有一个带有ReferenceQueue参数的构造函数。那么这个ReferenceQueue用来做什么呢？ 需要我们从enqueue这个函数来开始分析。当系统要回收Reference持有的对象引用referent的时候，Reference的enqueue函数会被调用，而在这个函数中调用了ReferenceQueue的enqueue函数。 那么我们来看看ReferenceQueue的enqueue函数做了什么？ 6.2.2 看看这段源代码 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class Reference&lt;T&gt; &#123; private static boolean disableIntrinsic = false; private static boolean slowPathEnabled = false; volatile T referent; /* Treated specially by GC */ final ReferenceQueue&lt;? super T&gt; queue; Reference queueNext; Reference&lt;?&gt; pendingNext; //返回此引用对象的引用。如果这个引用对象有由程序或垃圾收集器清除，然后此方法返回 public T get() &#123; return getReferent(); &#125; private final native T getReferent(); //清除此引用对象。调用此方法不会将对象加入队列 public void clear() &#123; this.referent = null; &#125; //是否引用对象已进入队列，由程序或垃圾收集器。 //如果该引用对象在创建队列时没有注册，则该方法将始终返回 public boolean isEnqueued() &#123; return queue != null &amp;&amp; queue.isEnqueued(this); &#125; //添加引用对象到其注册的队列，如果他的方法是通过java代码调用 public boolean enqueue() &#123; return queue != null &amp;&amp; queue.enqueue(this); &#125; Reference(T referent) &#123; this(referent, null); &#125; Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123; this.referent = referent; this.queue = queue; &#125;&#125; 6.3 看看ReferenceQueue的enqueue函数 6.3.1 源码说明 可以看到首先获取同步锁，然后调用了enqueueLocked(Reference)函数 6.3.2 看看这段代码 6.4 看看ReferenceQueue的enqueueLocked(Reference)函数 6.4.1 源码说明 通过 enqueueLocked函数可以看到ReferenceQueue维护了一个队列（链表结构），而enqueue这一系列函数就是将reference添加到这个队列（链表）中 6.4.2 看看这段代码 6.5 接着看看ReferenceQueue.isEnqueued()代码 6.5.1 让我们回到Reference源码中 可以看到除了enqueue这个函数还有一个isEnqueued函数，同样这个函数调用了ReferenceQueue的同名函数，源码如下： 12345boolean isEnqueued(Reference&lt;? extends T&gt; reference) &#123; synchronized (lock) &#123; return reference.queueNext != null &amp;&amp; reference.queueNext != sQueueNextUnenqueued; &#125;&#125; 6.5.2 源码分析说明 可以看到先获取同步锁，然后判断该reference是否在队列（链表）中。由于enqueue和isEnqueue函数都要申请同步锁，所以这是线程安全的。 这里要注意“reference.queueNext != sQueueNextUnenqueued”用于判断该Reference是否是一个Cleaner类，在上面ReferenceQueue的enqueueLocked函数中我们可以看到如果一个Reference是一个Cleaner，则调用它的clean方法，同时并不加入链表，并且将其queueNext设置为sQueueNextUnequeued，这是一个空的虚引用 6.6 那么enqueueLocked(Reference)函数中的Cleaner是做什么的 在stackoverflow网站中找到这个解释 sun.misc.Cleaner是JDK内部提供的用来释放非堆内存资源的API。JVM只会帮我们自动释放堆内存资源，但是它提供了回调机制，通过这个类能方便的释放系统的其他资源。 可以看到Cleaner是用于释放非堆内存的，所以做特殊处理。 通过enqueue和isEnqueue两个函数的分析，ReferenceQueue队列维护了那些被回收对象referent的Reference的引用，这样通过isEnqueue就可以判断对象referent是否已经被回收，用于一些情况的处理。 6.7 软引用SoftReference源码 6.7.1 关于这段源码分析 可以看到SoftReference有一个类变量clock和一个变量timestamp，这两个参数对于SoftReference至关重要。 clock：记录了上一次GC的时间。这个变量由GC（garbage collector）来改变。 timestamp：记录对象被访问（get函数）时最近一次GC的时间。 那么这两个参数有什么用？ 我们知道软引用是当内存不足时可以回收的。但是这只是大致情况，实际上软应用的回收有一个条件： clock - timestamp &lt;= free_heap * ms_per_mb free_heap是JVM Heap的空闲大小，单位是MB ms_per_mb单位是毫秒，是每MB空闲允许保留软引用的时间。Sun JVM可以通过参数-XX:SoftRefLRUPolicyMSPerMB进行设置 举个栗子： 目前有3MB的空闲，ms_per_mb为1000，这时如果clock和timestamp分别为5000和2000，那么 5000 - 2000 &lt;= 3 * 1000 条件成立，则该次GC不对该软引用进行回收。 所以每次GC时，通过上面的条件去判断软应用是否可以回收并进行回收，即我们通常说的内存不足时被回收。 6.7.2 源码如下所示 123456789101112131415161718public class SoftReference&lt;T&gt; extends Reference&lt;T&gt; &#123; static private long clock; private long timestamp; public SoftReference(T referent) &#123; super(referent); this.timestamp = clock; &#125; public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); this.timestamp = clock; &#125; public T get() &#123; T o = super.get(); if (o != null &amp;&amp; this.timestamp != clock) this.timestamp = clock; return o; &#125; &#125; 6.8 弱引用WeakReference源码 6.8.1 源码分析说明 没有其他代码，GC时被回收掉。 6.8.2 源码如下所示 12345678public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public WeakReference(T referent) &#123; super(referent); &#125; public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125; &#125; 6.9 虚引用PhantomReference源码 6.9.1 源码分析说明 可以看到get函数返回null，正如前面说得虚引用无法获取对象引用。（注意网上有些文章说虚引用不持有对象的引用，这是有误的，通过构造函数可以看到虚引用是持有对象引用的，但是无法获取该引用 同时可以看到虚引用只有一个构造函数，所以必须传入ReferenceQueue对象。 前面提到虚引用的作用是判断对象是否被回收，这个功能正是通过ReferenceQueue实现的。 这里注意：不仅仅是虚引用可以判断回收，弱引用和软引用同样实现了带有ReferenceQueue的构造函数，如果创建时传入了一个ReferenceQueue对象，同样也可以判断。 6.9.2 源码如下所示 12345678public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public T get() &#123; return null; &#125; public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125; &#125; 7.附件原文地址：https://blog.csdn.net/m0_37700275/article/details/79820814","tags":[{"name":"android","slug":"android","permalink":"http://wzmyyj.top/tags/android/"}]},{"title":"【IT】关于HTTP协议你需要知道这些","date":"2018-06-09T03:45:50.000Z","path":"2018/06/09/it_5/","text":"HTTP超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。 HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 主要特征 支持B/S及C/S模式。 简单快速：2.1 客户向服务器请求服务时，只需传送请求方法和路径。2.2 请求方法常用的有GET、HEAD、POST等，分别规定了客户与服务器不同的联系类型。2.3 HTTP协议简单，使得HTTP服务器的程序规模小，通信速度快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 请求方法一共有八种请求方式： GET向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 HEAD与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 POST向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT向指定资源位置上传其最新内容。 DELETE请求服务器删除Request-URI所标识的资源。 TRACE回显服务器收到的请求，主要用于测试或诊断。 OPTIONS这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 响应HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 状态行HTTP-Version Status-Code Reason-Phrase CRLF1.1 HTTP-Version表示服务器HTTP协议的版本；1.2 Status-Code表示服务器发回的响应状态代码；1.3 Reason-Phrase表示状态代码的文本描述。 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常见状态代码、状态描述、说明：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常其他代码请参考这篇 1例如：HTTP/1.1 200 OK （CRLF） 消息报头内容较长，请参考HTTP协议详解（真的很经典） 响应正文就是服务器返回的资源的内容。 协议例子下面是一个HTTP客户端与服务器之间会话的例子，运行于www.google.com，端口80。 请求信息发出的请求信息（message request）包括以下几个: 请求行（例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件）。 请求头（例如Accept-Language: en）。 空行。 其他消息体。 请求行和标题必须以作为结尾。空行内必须只有而无其他空格。在HTTP/1.1协议中，所有的请求头，除Host外，都是可选的。 客户端请求12GET / HTTP/1.1Host: www.google.com （末尾有一个空行。第一行指定方法、资源路径、协议版本；第二行是在1.1版里必带的一个header作用指定主机） 服务器应答123456789HTTP/1.1 200 OKContent-Length: 3059Server: GWS/2.0Date: Sat, 11 Jan 2003 02:44:04 GMTContent-Type: text/htmlCache-control: privateSet-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqyX9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.comConnection: keep-alive （紧跟着一个空行，并且由HTML格式的文本组成了Google的主页） 版本超文本传输协议（HTTP）已经演化出了很多版本，它们中的大部分都是向下兼容的。在 RFC 2145 中描述了HTTP版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。 HTTP/0.9已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。 HTTP/1.0这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。 HTTP/1.1持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。HTTP/1.1相较于HTTP/1.0协议的区别主要体现在： 缓存处理 带宽优化及网络连接的使用 错误通知的管理 消息在网络中的发送 互联网地址的维护 安全性及完整性 在HTTP 0.9和1.0中，TCP连接在每一次请求/回应对之后关闭。在HTTP 1.1中，引入了保持连接的机制，一个连接可以重复在多个请求/回应使用。持续连接的方式可以大大减少等待时间，因为在发出第一个请求后，双方不需要重新运行TCP交握程序。 HTTP/2当前版本，于2015年5月作为互联网标准正式发布。 TCP/IP 尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。 相关阅读下一篇博客：TCP协议中的三次握手和四次挥手","tags":[{"name":"IT","slug":"IT","permalink":"http://wzmyyj.top/tags/IT/"}]},{"title":"【java】获取中文首字母","date":"2018-06-08T08:21:29.000Z","path":"2018/06/08/java_2/","text":"中文首字母有时候，比如微信上根据名字拼音首字母排序并检索。那么用Java获取中文首字母是怎么实现的呢？ 代码不多说，直接上代码：（写个工具类）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class FirstCharUtil &#123; // 简体中文的编码范围从B0A1（45217）一直到F7FE（63486） private static int BEGIN = 45217; private static int END = 63486; // 按照声 母表示，这个表是在GB2312中的出现的第一个汉字， //也就是说“啊”是代表首字母a的第一个汉字。 // i, u, v都不做声母, 自定规则跟随前面的字母 private static char[] charTable = &#123; '啊', '芭', '擦', '搭', '蛾', '发', '噶', '哈', '哈', '击', '喀', '垃', '妈', '拿', '哦', '啪', '期', '然', '撒', '塌', '塌', '塌', '挖', '昔', '压', '匝', &#125;; // 二十六个字母区间对应二十七个端点 // GB2312码汉字区间十进制表示 private static int[] table = new int[27]; // 对应首字母区间表 private static char[] initialTable = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'H', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'T', 'T', 'W', 'X', 'Y', 'Z', &#125;; // 初始化 static &#123; for (int i = 0; i &lt; 26; i++) &#123; // 得到GB2312码的首字母区间端点表，十进制。 table[i] = gbValue(charTable[i]); &#125; table[26] = END;// 区间表结尾 &#125; // ------------------------public方法区------------------------ // 根据一个包含汉字的字符串返回一个汉字拼音首字母的字符串。 public static String first(String S) &#123; String Result = \"\"; if (S == null || S.equals(\"\")) &#123; return \"#\"; &#125; char cs = S.charAt(0); try &#123; Result += Char2Initial(cs); &#125; catch (Exception e) &#123; Result = \"%\"; e.printStackTrace(); &#125; return Result; &#125; // ------------------------private方法区------------------------ /** * 输入字符,得到他的声母,英文字母返回对应的大写字母,其他非简体汉字返回 '#' */ private static char Char2Initial(char ch) &#123; // 对英文字母的处理：小写字母转换为大写，大写的直接返回 if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; return (char) (ch - 'a' + 'A'); &#125; if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; return ch; &#125; // 对非英文字母的处理：转化为首字母，然后判断是否在码表范围内， // 若不是，则直接返回。 // 若是，则在码表内的进行判断。 int gb = gbValue(ch);// 汉字转换首字母 if ((gb &lt; BEGIN) || (gb &gt; END))// 在码表区间之前，直接返回 &#123; return '#'; &#125; int i; for (i = 0; i &lt; 26; i++) &#123; // 判断匹配码表区间，匹配到就break,判断区间形如“[,)” if ((gb &gt;= table[i]) &amp;&amp; (gb &lt; table[i + 1])) &#123; break; &#125; &#125; if (gb == END) &#123;// 补上GB2312区间最右端 i = 25; &#125; return initialTable[i]; // 在码表区间中，返回首字母 &#125; /** * 取出汉字的编码 cn 汉字 */ private static int gbValue(char ch) &#123;// 将一个汉字（GB2312）转换为十进制表示。 String str = new String(); str += ch; try &#123; byte[] bytes = str.getBytes(\"GB2312\"); if (bytes.length &lt; 2) &#123; return 0; &#125; return (bytes[0] &lt;&lt; 8 &amp; 0xff00) + (bytes[1] &amp; 0xff); &#125; catch (Exception e) &#123; return 0; &#125; &#125;&#125; 使用方式：1String first = FirstCharUtil.first(\"加哇\"); 说明 原理： GB2312编码中的中文是按照拼音排序的。 注意：一些生僻的字无法获得正确的首字母，原因是这些字都是后加入的。","tags":[{"name":"java","slug":"java","permalink":"http://wzmyyj.top/tags/java/"}]},{"title":"【IT】Hexo+GitHub搭建个人博客网站","date":"2018-06-06T08:44:28.000Z","path":"2018/06/06/it_4/","text":"前言今天，带大家利用Hexo和GitHub搭建属于自己的个人博客。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成##静态网页##。传送门：Hexo官网中文文档 环境配置1. 安装&amp;配置git 访问git官网，下载git。 双击exe文件安装，一路next即可。 安装好git之后，配置用户名和邮箱。打开git-bash： 1234# 配置全局用户名git config --global user.name \"yourname\"# 配置全局邮箱git config --global user.email \"youremail@qq.com\" 用户名和邮箱同你的GitHub（如果没有，去GitHub官网注册一个，注册好后记得邮箱验证才能使用。） 配置ssh。打开git-bash：12#输入，回车ssh-keygen 复制（右键+复制，不能ctrl+c，这里ctrl+c是结束命令的意思）图中的/c/Users/Administrator/.ssh/id_rsa，然后把它粘贴（右键+粘贴）到冒号后面，然后回车，回车，回车。。。直到结束（中间的冒号，除了第一个不用管只管回车）。 github上生成ssh key，是本地Git绑定GitHub。网页上打开github -&gt; 点击头像 -&gt; Settings -&gt; 左边菜单找到 SSH and GPG keys -&gt; New SSH key（绿色按钮）-&gt; title随便填（用英文）-&gt; key值（打开/c/Users/Administrator/.ssh/id_rsa所在的文件夹，找到id_rsa.pub，注意是pub后缀那个文件，用记事本打开，复制里面的内容，粘贴到key值。） -&gt; 点击下面的Add SSH key -&gt; 完成。 2. 下载安装Node.js node.js下载地址 安装步骤：一路默认就行（安装路径根据自己需要更改） 安装&amp;使用Hexo 在D盘下（其他地方也可以）创建一个空文件夹（命名为你主页的名字或者HEXO，随便啦，这里以名为MyBlog为例） 打开cmd命令窗口（桌面任务栏最左边那个wins图标-&gt; 搜索 -&gt; 输入cmd ，回车）。切换到D盘：（输入，回车）D: -&gt; 切换到刚才建的空文件夹：（输入，回车）cd MyBlog。 安装Hexo 1234# 切换国内源npm config set registry=\"http://registry.cnpmjs.org\"# 安装hexonpm install -g hexo 等待安装完成。 初始化Hexo：1234# 初始化Hexohexo init# 安装必要模块npm install 这时，MyBlog文件夹下就生成了一些文件。文件目录如下：1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 到此博客已经配置好了（虽然是默认的样子） 测试一下：1234# 生成静态文件hexo g // 或 hexo generate# 本地测试hexo s // 或 hexo server 然后浏览器上查看 http://localhost:4000 是不是可以看到一个简单的网页（如果不能，有可能是4000端口被别的程序占用了，自行百度解决方案）。 个性化1. _config.yml文件打开该目录下的_config.yml文件。（用什么软件打开？你可以用editplus或者vs 等，也可以直接用记事本，就是比较难看，建议下个editplus吧。） 修改成你想要的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 换成你的主页标题subtitle: 主页副标题description: 主页介绍的一句话author: 你的名字language: zh-CN #语言timezone: Asia/Shanghai #时区# URL## If your site is put in a subdirectory, ##set url as 'http://yoursite.com/child' and root as '/child/'url: http://voidking.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: pageindex_generator: per_page: 5archive_generator: per_page: 500 yearly: true monthly: true tag_generator: per_page: 100 category_generator: per_page: 100 # Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: 你用的主题文件夹名字 # themes下的文件# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: GitHub仓库地址 branch: master 2. 修改主题在hexo官网主题中找一个喜欢的主题。 找到后，一般都有介绍怎么使用该主题的文章，如果没有，把网页拉到最下面。看到：2018 | Powered by Hexo Theme by Aath点击Theme by 后面的连接，一般会简介到本主题在GitHub上的仓库地址。 根据说明，下载配置主题。 下载主题。比如：12# 切换到MyBlog文件下，cmd执行git clone -b master https://github.com/lewis-geek/hexo-theme-Aath.git themes/aath 一般，它会自动下载到themes文件夹下。 跟换博客的主题：下载好后，你在_config.yml（主题是MyBlog文件夹下的）中的theme：处配置成你下在的主题名字（就是下载的主题文件夹名字 ） 配置主题：根据GitHub上的说明配置themes/主题名目录下的_config.yml（不要与MyBlog的_config.yml搞混）。不同主题，配置起来不一样，所以在此不详解了。 发布到GitHub Github上新建仓库：打开GitHub网页，点击头像旁边的“+”号 -&gt; New repository -&gt; 填写名字（必须是：你GitHub的名字.github.io） 本地配置Git：在MyBlog文件夹下的_config.yml配置（大约在底部位置）： 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/wzmyyj/wzmyyj.github.io.git branch: master 上传： 123456# 如果想把原来的清除hexo clean# 重新生成静态文件hexo g# 上传到提交文件hexo d 第一次提交需要GitHub登录账号和密码。 上传完成后，浏览器打开：https://你的GitHub名字.github.io 就是你的博客主页地址了。（GitHub响应比较慢，刚上传需要等一小会才能打开最新的。） 写文章 新建一篇文章：12# 新建hexo new post 文章名 在Myblog\\source\\_posts目录下你将看到一个新建的文章名.md文件。 编辑文章：用editplus打开编辑，用Markdown格式书写。 保存时，记得把编码方式改成utf-8。Document -&gt; File Encoding -&gt; Convert Encoding… 建议用简书写（简书设置里把编辑器改成Markdown），然后复制过去。好处是图片存在简书上，访问起来快些。 上传：（和前面一样）12345678# 如果想把原来的清除hexo clean# 重新生成静态文件hexo g# 本地测试hexo s# 上传到提交文件hexo d 到此，你的博客主页已经完成。 跟换域名 购买一个域名。（阿里云，腾讯云，万网均可注册购买域名） 修改你域名的DNS地址为 dns22.hichina.com, dns21.hichina.com 域名解析上，CNAME到你的GitHub名字.github.io 然后在你的本地站点目录里的source目录下添加一个CNAME文件。以文本编辑器打开CNAME，里面添加你的域名（不加http://）。 在MyBlog文件夹下的_config.yml配置url： 1234# URL## If your site is put in a subdirectory, ## set url as 'http://yoursite.com/child' and root as '/child/'url: http://wzmyyj.top //你的域名 重新生成静态文件和上传到GitHub。 附件1. 参考文献：Hexo环境搭建2018年5月版搭建个人博客-hexo+github详细完整步骤我的博客是如何搭建的（github pages + HEXO + 域名绑定）Hexo中文文档 2. 我的主页： 欢迎大家浏览我的主页：http://wzmyyj.top/","tags":[{"name":"IT","slug":"IT","permalink":"http://wzmyyj.top/tags/IT/"}]},{"title":"【IT】提问的智慧","date":"2018-06-04T12:08:19.000Z","path":"2018/06/04/it_3/","text":"《提问的智慧》艾瑞克.史蒂文.雷蒙德（Eric Steven Raymond）Thyrsus Enterprises &#x65;&#x73;&#114;&#x40;&#116;&#x68;&#121;&#114;&#x73;&#x75;&#x73;&#x2e;&#99;&#x6f;&#x6d;瑞克.莫恩（Rick Moen） &#114;&#x65;&#115;&#x70;&#111;&#x6e;&#100;&#x2d;&#x61;&#117;&#116;&#x6f;&#x40;&#108;&#x69;&#x6e;&#117;&#120;&#109;&#97;&#102;&#105;&#97;&#x2e;&#99;&#x6f;&#109;版权©2001, 2006 Eric S. Raymond, Rick Moen 传送门中文：《提问的智慧》 原文：《How To Ask Questions The Smart Way》 要求声明：（我们不提供该项目的服务支持！）","tags":[{"name":"IT","slug":"IT","permalink":"http://wzmyyj.top/tags/IT/"}]},{"title":"【图片】仅仅是几张图而已哦^_^","date":"2018-06-01T13:20:06.000Z","path":"2018/06/01/pic_1/","text":"","tags":[{"name":"图片","slug":"图片","permalink":"http://wzmyyj.top/tags/图片/"}]},{"title":"【android】封装使用Toast","date":"2018-05-22T12:57:43.000Z","path":"2018/05/22/android_2/","text":"android.widget.Toast类Toast是Android中用来显示显示信息的一种机制，和Dialog不一样的是，Toast是没有焦点的，而且Toast显示的时间有限，过一定的时间就会自动消失。而且Toast主要用于向用户显示提示消息。 1,常规用法123Toast.makeText(context, \"一条消息\", Toast.LENGTH_SHORT).show();// 或Toast.makeText(context, \"一条消息\", Toast.LENGTH_LONG).show(); 其中context是上下文。 虽然只需要一行代码，但写起来并不方便。做个简单封装吧。 2,封装Toast123456789101112131415161718192021222324252627282930public class T &#123; private static Application app; private T() &#123; &#125; public static void init(Application app) &#123; T.app = app; &#125; public static void s(String msg) &#123; if (app == null) return; s(app, msg); &#125; public static void l(String msg) &#123; if (app == null) return; l(app, msg); &#125; public static void s(Context context, String msg) &#123; Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); &#125; public static void l(Context context, String msg) &#123; Toast.makeText(context, msg, Toast.LENGTH_LONG).show(); &#125;&#125; 使用时，先在自己写的Application中初始化。1234567public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); T.init(this); &#125;&#125; 使用时，只需：123T.s(\"一条消息\");// 时间较短 //或T.l(\"一条消息\");// 时间较长 如果没有在Application中初始化。也可以：123T.s(context,\"一条消息\");// 时间较短 //或T.l(context,\"一条消息\");// 时间较长 虽然T的命名是不规范的，但是用起来真是方便。当它比较特殊常用就好啦。 其他还有对Log的简单封装：Android中的Log类","tags":[{"name":"android","slug":"android","permalink":"http://wzmyyj.top/tags/android/"}]},{"title":"【android】日志工具Log类","date":"2018-05-22T12:43:30.000Z","path":"2018/05/22/android_1/","text":"android.util.Log类android.util.Log常用的方法有以下5个：Log.v()， Log.d() ，Log.i() ，Log.w() 以及 Log.e() 。根据首字母对应VERBOSE，DEBUG，INFO， WARN，ERROR。 Log.v 的输出颜色为黑色的，任何消息都会输出，这里的v代表verbose啰嗦的意思。 Log.d的输出颜色为蓝色的，仅输出debug调试的意思，但他会输出上层的信息，过滤起来可以通过DDMS的Logcat标签来选择。 Log.i的输出颜色为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息。 Log.w的输出颜色为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。 Log.e的输出颜色为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。 1,常规用法12345Log.v(TAG,\"一条啰嗦日志\");Log.d(TAG,\"一条调试日志\");Log.i(TAG,\"一条提示日志\");Log.w(TAG,\"一条警告日志\");Log.e(TAG,\"一条错误日志\"); 其中TAG为字符串。用于标记。同一个应用TAG基本可以成一样。并且，应用打包发布时，最好把全部Log注释掉，否则将产生不必要的资源消耗（虽然很小）。 2,分装Log123456789101112131415161718192021222324252627282930313233343536373839404142public class L &#123; private static String TAG = \"WZM\"; // 开关 private static boolean debug = true; private L() &#123; &#125; public static void setTAG(String TAG) &#123; L.TAG = TAG; &#125; public static void setDebug(boolean debug) &#123; L.debug = debug; &#125; public static void v(String msg) &#123; if (debug) Log.v(TAG, msg); &#125; public static void d(String msg) &#123; if (debug) Log.d(TAG, msg); &#125; public static void i(String msg) &#123; if (debug) Log.i(TAG, msg); &#125; public static void w(String msg) &#123; if (debug) Log.w(TAG, msg); &#125; public static void e(String msg) &#123; if (debug) Log.e(TAG, msg); &#125;&#125; 使用时：12345L.v(\"一条啰嗦日志\");L.d(\"一条调试日志\");L.i(\"一条提示日志\");L.w(\"一条警告日志\");L.e(\"一条错误日志\"); 并且，可在Application中设置开关（是否输出日志）或TAG（默认WZM）12345678public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); L.setTAG(\"TAG\"); L.setDebug(false); &#125;&#125; 打包发布时，debug设为false即可。 其他还有对Toast的简单封装：Android 封装Toast","tags":[{"name":"android","slug":"android","permalink":"http://wzmyyj.top/tags/android/"}]},{"title":"【设计模式】工厂模式","date":"2018-05-18T09:52:10.000Z","path":"2018/05/18/design_3/","text":"工厂模式工厂模式（Factory Pattern）就是专门负责将大量有共同接口的类实例化，而且不必事先知道每次是要实例化哪一个类的模式。它定义一个用于创建对象的接口，由子类决定实例化哪一个类。工厂模式相当于创建实例对象的new，经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的。 UML类图 抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。 具体产品类（ProductX）：实现基类中的抽象方法（多个不同的具体产品，X=1,2,3..）。 抽象工厂类或接口（AbstractFactory）：定义具体工厂的公共接口。 具体工厂类（FactoryX）：定义创建对应具体产品实例的方法。（每个工厂对应一种具体产品，X=1,2,3…）。 案例分析既然是工厂，当然是要生产产品。那我们来造什么好呢？，，嗯，，，造小孩？NO，NO，NO！我们还是来造英雄吧。 场景：玩《英雄联盟》（5v5 moba端游）新开一局游戏，游戏开始每个玩家需要选一个信赖的英雄。选好后，英雄会很兴奋，说一句专属的台词。那么程序上是new出该英雄的对象，执行该对象的say()方法。 常规写法：建立英雄类：123456public abstract class Hero &#123; protected String name; public abstract void say();&#125; 寒冰射手-艾希类（继承Hero类）：1234567891011121314public class Ashe extends Hero &#123; // 简化构造方法，只弄个名字。 public Ashe() &#123; this.name = \"寒冰射手-艾希\"; &#125; // 艾希台词 // 艾希台词 @Override public void say() &#123; System.out.println(name + \"：\" + \"世间万物皆系于一箭之上。\"); &#125;&#125; 类似的写了亚索类，光辉类，盖伦类，剑圣类（全部英雄的话，还有好多）。再写个枚举（可以不需要，仅仅拿来当对应标识使用）。1234567public enum Who &#123; Ashe, Garen, Yi, Lux, Yasuo&#125; 然后客户端调用：（菜鸟写法）1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Client1 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 Ashe ashe = new Ashe(); ashe.say(); break; case Yasuo: // 亚索 Yasuo yasuo = new Yasuo(); yasuo.say(); break; case Garen: // 德玛 Garen garen = new Garen(); garen.say(); break; case Lux: // 光辉 Lux lux = new Lux(); lux.say(); break; case Yi: // 剑圣 Yi yi = new Yi(); yi.say(); break; &#125; &#125;&#125; 客户端调用：（好学生写法，父类的子类引用）123456789101112131415161718192021222324252627282930313233public class Client2 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); Hero hero = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 hero = new Ashe(); break; case Yasuo: // 亚索 hero = new Yasuo(); break; case Garen: // 德玛 hero = new Garen(); break; case Lux: // 光辉 hero = new Lux(); break; case Yi: // 剑圣 hero = new Yi(); break; &#125; hero.say(); &#125;&#125; 这里客户端需要知道： 英雄怎么构造，怎么new出来。（事实上英雄的构造远没有这么简单。） 每个英雄的方法怎么调用。（这里都是say()方法） 我们前面提到，利用工厂可以把创建对象的过程封装掉，客户端只要知道得到对象后调用其方法即可。用工厂代替new的过程。那就看看工厂方法怎么去实现吧。 工厂模式写法先建立一个工厂类的接口：1234public interface Factory &#123; //创建英雄的接口 public abstract Hero create();&#125; 然后建立不同英雄对应的工厂实现类。比如艾希工厂：123456public class AsheFactory implements Factory &#123; //实现具体的创建英雄的方法。 public Hero create() &#123; return new Ashe(); &#125;&#125; 同样的建立亚索工厂，光辉工厂，盖伦工厂，剑圣工厂等。 然后客户端调用：12345678910111213141516171819202122232425262728293031323334public class Client3 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); Factory factory = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希工厂 factory = new AsheFactory(); break; case Yasuo: // 亚索工厂 factory = new YasuoFactory(); break; case Garen: // 德玛工厂 factory = new GarenFactory(); break; case Lux: // 光辉工厂 factory = new LuxFactory(); break; case Yi: // 剑圣工厂 factory = new YiFactory(); break; &#125; Hero hero = factory.create(); hero.say(); &#125;&#125; switch中不再是英雄的创建过程，而是选择英雄工厂的过程。根据不同name选择不同的工厂，然后由工厂去实例化具体英雄对象。 新增一个英雄，就新增一个对应的工厂。需要修改的只有客户端代码。 如果不需要新增也不需要减少。我们是不是可以把工厂的选择封装起来。让多家工厂合并成一家工厂。那就是接下来要讲的简单工厂模式 简单工厂模式简单工厂模式（Simple Factory Pattern）是类的创建模式，又叫做静态工厂方法模式。就是由一个工厂类根据传入的参量决定创建出哪一种产品类的实例。与上面工厂模式的区别就是它只需要一个工厂。 UML类图 抽象产品类（AbstractProduct）：类中定义抽象一些方法，在子类中具体实现。 具体产品类（ConcreteProduct）：实现基类中的抽象方法。 工厂类（Factory）：用以封装实例化对象过程，根据传入的参数决定生产不同的产品。 利用简单工厂的写法：其他地方不变，将工厂合并成一个工厂类，并在内部写个静态方法，根据传入的参数决定创建不同的英雄对象：12345678910111213141516171819202122232425262728293031public class SimpleFactory &#123; public static Hero create(String name) &#123; Hero hero = null; switch (Who.valueOf(name)) &#123; case Ashe: // 艾希 hero = new Ashe(); break; case Yasuo: // 亚索 hero = new Yasuo(); break; case Garen: // 德玛 hero = new Garen(); break; case Lux: // 光辉 hero = new Lux(); break; case Yi: // 剑圣 hero= new Yi(); break; &#125; return hero; &#125;&#125; 客户端代码做简单修改：12345678910public class Client4 &#123; public static void main(String[] args) &#123; Scanner can = new Scanner(System.in); String name = can.next(); can.close(); // 根据传入的名字构建不同的英雄。 Hero hero = SimpleFactory.create(name); hero.say(); &#125;&#125; 客户端不需要知道对象的构建过程，只要传入参数得到不同对象。 但是简单工厂是固定的，如果增减英雄他就要修改。不符合开闭原则。这时候用前面工厂模式好，把修改转移给客户端，而不修改工厂代码。 结果选个盖伦试试： 不能浪，不能浪。 抽象工厂模式请看下篇【设计模式】抽象工厂模式。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wzmyyj.top/tags/设计模式/"}]},{"title":"【设计模式】单例模式","date":"2018-04-17T13:20:06.000Z","path":"2018/04/17/design_2/","text":"单例模式单例模式（Singleton Pattern）是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。 某个类只能有一个实例。 它必须自行创建这个实例。 它必须自行向整个系统提供这个实例。 单例模式关键点： 构造函数私有化（不让外部创建此类对象）。 通过一个静态方法或枚举返回单例类对象。 多线程环境下，确保单例（难点）。 反序列化不会重新构建对象。 饿汉式12345678910111213141516171819public class Singleton &#123; // 单例对象 private final static Singleton INSTANCE = new Singleton(); // 或 // private final static Singleton INSTANCE; // static &#123; // INSTANCE = new Singleton(); // &#125; // 私有构造方法 private Singleton() &#123; &#125; // 公有静态方法用于获取单例对象 public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 线程安全。但是没使用它时，就已经建立了对象，开销内存。 懒汉式12345678910111213141516public class Singleton &#123; // 单例对象 private static Singleton INSTANCE = null; // 私有构造方法 private Singleton() &#123; &#125; // synchronized关键字修饰静态方法 public static synchronized Singleton getInstance() &#123; if (null == INSTANCE) &#123;// 空值判断 INSTANCE = new Singleton(); &#125; return INSTANCE; &#125;&#125; 在第一次调用getInstance()时，创建单例对象。synchronized关键字修饰，使getInstance()是一个同步方法。保证多线程情况下单例对象的唯一。但是，同步会耗费资源。 双检锁式（Double Check Lock（DCL））1234567891011121314151617181920public class Singleton &#123; // 单例对象，volatile关键字保证INSTANCE的原子性 private volatile static Singleton INSTANCE = null; // 私有构造方法 private Singleton() &#123; &#125; // 两次空值检查，synchronized关键字同步 public static Singleton getInstance() &#123; if (null == INSTANCE) &#123; synchronized (Singleton.class) &#123; if (null == INSTANCE) &#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 语句INSTANCE = new Singleton();在编译时的步骤如下： 给Singleton的实例分配内存。 调用Singleton()的构造函数，初始化成员字段。 将INSTANCE 对象指向分配的内存空间（此时对象非空）。 Java编译器允许处理器乱序执行。上诉的2，3两步的顺序可能被打乱。打乱后，非空判断的线程不安全。在JDK1.5之后，调整了JVM，具体化了volatile关键字，表示此操作是一个原子操作，不能中间被分割执行。使用volatile关键字会影响性能。 静态内部类123456789101112131415public class Singleton &#123; // 内部类，包含单例的对象 private static class SingletonHolder &#123; public static final Singleton INSTANCE = new Singleton(); &#125; // 私有构造方法 private Singleton() &#123; &#125; // 公有静态方法用于获取单例对象 public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 第一次加载Singleton时，SingletonHolder不会被加载。只用调用getInstance()时，才加载SingletonHolder，并创建INSTANCE。推荐大家使用。 枚举式123public enum SingletonEnum &#123; INSTANCE;&#125; 虽说代码简单，enum的实质也是class（编译时，会先翻译成一个class）。优点是反序列化也不会重新生成新的实例。 前几种方式，如果要避免反序列化也不会重新生成新的实例。需要重写：123private Object readResolve() throws ObjectStreamException&#123; return INSTANCE;&#125; 单例管理类一个程序可能有多个单例对象。先建立一个上诉管理类。1234567891011121314151617181920public class SingletonManager &#123; // 容器 private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String, Object&gt;(); // 私有构造方法 private SingletonManager() &#123; &#125; // 注册单例 public static void ascendSingleton(String key, Object instance) &#123; if (!objMap.containsKey(key)) &#123; objMap.put(key, instance); &#125; &#125; // 获得单例对象 public static Object getInstance(String key) &#123; return objMap.get(key); &#125;&#125; 通过注册，可以管理多种类型的单例，使用统一接口，隐藏具体实现。使用时：12//注册单例SingletonManager.ascendSingleton(\"SingletonKey\",Singleton.getInstance()); 12//获得单例对象Singleton singleton = SingletonManager.getInstance(\"SingletonKey\"); 优点 只有一个对象，全局使用。 只需要建立一次，占一个内存，节约资源。 缺点 没有接口，难以扩展。 生命周期长，如果引用短生命周期对象会内存泄漏。 补充通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wzmyyj.top/tags/设计模式/"}]},{"title":"【设计模式】面向对象六大原则","date":"2018-04-14T16:08:04.000Z","path":"2018/04/15/design_1/","text":"设计模式设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化。设计模式分为三种类型，分别是：创建型模式、结构型模式，行为型模式。 23种设计模式 创建型模式，共5种：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 六大原则1，单一职责原则（Single Responsibility Principle, SRP）定义：一个类应只包含单一的职责。 如果一个类职责过多，代码量就多，而使用起来显得过分冗余，不利于复用。 如果修改某个职责，可能影响另一个职责。 2，开放封闭原则(Open - ClosedPrinciple ,OCP)定义：一个模块、类、函数应当是对修改关闭，对扩展开放。 修改原有的代码可能会导致原本正常的功能出现问题。 当需求改变时，最好通过扩展来实现，增加新的方法或类满足需求，而不是去修改原有代码。 3，里氏代换原则( Liskov Substitution Principle ,LSP )定义：使用父类的地方能够使用子类来替换，反过来，则不行。 使用子类对象去替换父类对象，程序将不会产生错误。 程序中尽量使用基类类型来对对象进行定义，如父类的子类引用，而在运行时再确定其子类类型，用子类对象来替换父类对象。 4，依赖倒转原则( Dependence Inversion Principle ,DIP )定义：抽象不应该依赖于细节，细节应当依赖于抽象。 即要面向接口编程，而不是面向具体实现去编程。 高层模块不应该依赖低层模块，应该去依赖抽象。 方法定义时，传入对象用抽象类型，实际使用时传入子类对象。 5，接口隔离法则(Interface Segregation Principle，ISL）定义：一个类对另一个类的依赖应该建立在最小的接口上。 一个类不应该依赖他不需要的接口，接口的方法全要用得到。 接口粒度要尽可能小，尽量不能再分割。一个接口的方法过多，可以拆成多个接口。 6，迪米特法则(Law of Demeter, LoD)定义：一个类尽量不要与其他类发生关系 一个类对其他类知道的越少越好，耦合越小。导入的东西越少越好。 当修改一个类时，其他类的影响就越小，发生错误的可能性就越小。 附件设计模式DemoGitHub源码：https://github.com/wzmyyj/Design-Pattern","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wzmyyj.top/tags/设计模式/"}]},{"title":"【java】归并排序算法","date":"2018-04-14T13:35:08.000Z","path":"2018/04/14/java_1/","text":"归并排序归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序算法稳定，数组需要O(n)的额外空间，链表需要O(log(n))的额外空间，时间复杂度为O(nlog(n))，算法不是自适应的，不需要对数据的随机读取。 工作原理 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。 设定两个指针，最初位置分别为两个已经排序序列的起始位置。 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。 重复步骤3直到某一指针达到序列尾。 将另一序列剩下的所有元素直接复制到合并序列尾。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class MergeSortTest &#123; public static void main(String[] args) &#123; //测试数据 int A[] = &#123; 1, 6, 4, 5, 2, 9, 7, 23, 56, 43, 99 &#125;; // 排序前 System.out.println(\"排序前：\"); for (int a : A) &#123; System.out.print(a + \" \"); &#125; System.out.println(); // 排序 mergeSort(A); // 排序后 System.out.println(\"排序后：\"); for (int a : A) &#123; System.out.print(a + \" \"); &#125; System.out.println(); &#125; // 排序入口 public static void mergeSort(int[] A) &#123; sort(A, 0, A.length - 1); &#125; //递归 public static void sort(int[] A, int start, int end) &#123; if (start &gt;= end) return; // 找出中间索引 int mid = (start + end) / 2; // 对左边数组进行递归 sort(A, start, mid); // 对右边数组进行递归 sort(A, mid + 1, end); // 合并 merge(A, start, mid, end); &#125; // 将两个数组进行归并，归并前面2个数组已有序，归并后依然有序 public static void merge(int[] A, int start, int mid, int end) &#123; int[] temp = new int[A.length];// 临时数组 int k = 0; int i = start; int j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; // 从两个数组中取出较小的放入临时数组 if (A[i] &lt;= A[j]) &#123; temp[k++] = A[i++]; &#125; else &#123; temp[k++] = A[j++]; &#125; &#125; // 剩余部分依次放入临时数组（实际上两个while只会执行其中一个） while (i &lt;= mid) &#123; temp[k++] = A[i++]; &#125; while (j &lt;= end) &#123; temp[k++] = A[j++]; &#125; // 将临时数组中的内容拷贝回原数组中 （left-right范围的内容） for (int m = 0; m &lt; k; m++) &#123; A[m + start] = temp[m]; &#125; &#125;&#125; 对于算法，理解原理很重要。。。 附页GitHub源码：https://github.com/wzmyyj/MergeSort","tags":[{"name":"java","slug":"java","permalink":"http://wzmyyj.top/tags/java/"}]},{"title":"【IT】L2TP/IPSec配置教程","date":"2018-04-10T13:40:49.000Z","path":"2018/04/10/it_2/","text":"L2TP/IPSecL2TP是一种工业标准的Internet隧道协议，功能大致和PPTP协议类似，比如同样可以对网络数据流进行加密。不过也有不同之处，比如PPTP要求网络为IP网络，L2TP要求面向数据包的点对点连接；PPTP使用单一隧道，L2TP使用多隧道；L2TP提供包头压缩、隧道验证，而PPTP不支持。 服务器首先，需要一个境外服务器。我采用的是Vultr服务器（2.5刀每月）。购买方法见我的上篇博客：购买Vultr境外服务器。 配置服务器端我们采用的是Github上setup-ipsec-vpn这个脚本安装方法，不需要特别配置，简单安装。 1, Ubuntu &amp; Debian：1, 远程连接到上诉买的服务器。（默认的用户名是root） 1ssh root@服务器ip地址 这里，下一步会让你输入密码。复制粘贴（右键粘贴，不能Ctrl+v）即可。（控制台上不会显示出密码，粘贴后直接回车即可） 等待连接完成。 2, 刷新一下。复制粘贴下行代码。1sudo apt-get update 3, 安装脚本。复制粘贴下行代码。 1wget https://git.io/vpnsetup -O vpnsetup.sh &amp;&amp; sudo sh vpnsetup.sh 等待安装完成，需要点点时间。 安装好后，会自动分配 Username，Password，Pre-Shared key（一些参数，默认是一些随机数。） 4, 修改参数。 123456#所有变量值必须用 '单引号' 括起来#*不要* 在值中使用这些字符： \\ \" ' wget https://git.io/vpnsetup -O vpnsetup.sh&amp;&amp;sudo \\VPN_IPSEC_PSK='你的IPsec预共享密钥'\\VPN_USER='你的VPN用户名'\\VPN_PASSWORD='你的VPN密码' sh vpnsetup.sh 2, CentOS &amp; RHEL：首先，更新你的系统。第一步改成：1yum update 重启。这一步是可选的，但推荐。 按照与上面相同的步骤，但是 将 https://git.io/vpnsetup 换成 https://git.io/vpnsetup-centos。 到此，你的L2TP/IPSec类型VPN配置完成。 配置客户端1, 安卓手机设置–&gt;连接–&gt;VPN连接–&gt;添加连接–&gt;名称随便取–&gt;类型选L2TP/IPSec PSK–&gt;输入IP地址，预用共享密钥（不是L2TP密钥，未使用的不要填），用户名，密码–&gt;连接（如果第一次连接失败，重试可能仍失败，建议删除连接，重新配置）。 2, Windows电脑打开网络共享中心–&gt;设置新的连接或网络–&gt;连接到工作区–&gt;创建新的连接–&gt;使用我的Internet连接–&gt;填写地址和名称–&gt;填写用户名和密码（域不要填）–&gt;保存连接（不要立刻连接）–&gt;电脑上出现新的连接–&gt;右键–&gt;属性–&gt;安全–&gt;VPN类型（选L2TP/IPSec）–&gt;高级设置–&gt;填写密钥–&gt;保存，连接。 （不同win版本会有所不同。） 3, 其他百度一下，你就知道。 作用连接完成后，你就可以上Google，Facebook，YouTube，Twitter等网站啦。玩韩服七骑士。","tags":[{"name":"IT","slug":"IT","permalink":"http://wzmyyj.top/tags/IT/"}]},{"title":"【IT】购买Vultr服务器","date":"2018-04-07T08:11:50.000Z","path":"2018/04/07/it_1/","text":"Vultr服务器Vultr是一家美国的服务器厂商,这个VPS服务商是按小时收费的。这意味着,架设一台VPS的成本较低。 ##购买步骤 1, 登录官网：https://www.vultr.com/。注册一个自己的账号。 2, 确定需要的服务器配置。一般而言，我们只需要最低配置选择$2.5/月（大约15元/月）的即可。（好多可能售完，只有Miami还有$2.5的）。系统选择推荐Ubuntu （16.04或14.04）。 2.1, 地点 2.2, 系统 2.3, 附加服务 2.4, 主机名 3, 支付。选择支付宝扫码支付。至少支付$10（60多元）。 4, 购买步骤2选的服务器。 到此。你的服务器购买完毕。 管理Vultr服务器1, 服务器管理界面。 重点看ID，用户名和密码，以后需要用到。","tags":[{"name":"IT","slug":"IT","permalink":"http://wzmyyj.top/tags/IT/"}]}]